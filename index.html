<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sammy's Lifeblogging & Quantifying Analyser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, deleteDoc, serverTimestamp, FieldValue } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            onAuthStateChanged,
            getFirestore,
            doc,
            getDoc,
            setDoc,
            onSnapshot,
            collection,
            query,
            where,
            getDocs,
            deleteDoc,
            serverTimestamp,
        };
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border-left-color: #2563eb;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .source-checkbox-container {
            max-height: 150px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            background-color: #f8fafc;
        }
        .table-container {
            max-height: 500px;
            overflow: auto;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid #e2e8f0;
            white-space: nowrap;
        }
        th {
            background-color: #f4f6f9;
            color: #4a5568;
            font-weight: 600;
            cursor: pointer;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        tr:hover {
            background-color: #f7fafc;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100">

<div class="container">
    <h1 class="text-4xl font-bold text-center mb-10 text-gray-800">Sammy's Lifeblogging & Quantifying Analyser</h1>
    <div class="card mb-4 p-4 rounded-lg bg-yellow-100 text-yellow-800 text-sm">
        <p>Your unique user ID is: <strong id="user-id-display">Signing in...</strong></p>
        <p>This ID is used to store your data securely and privately in the cloud, allowing you to access it from any device.</p>
    </div>

    <div id="data-loading-status" class="flex items-center justify-center p-4 rounded-lg bg-blue-100 text-blue-800 text-sm mb-4">
        <div class="spinner mr-3"></div>
        <p>Loading data sources...</p>
    </div>

    <div id="message-box" class="fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white font-semibold transition-opacity duration-300 opacity-0" role="alert"></div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">1. Manually Add Data</h2>
        <p class="text-gray-600 mb-4 flex items-center">
            Use this section to add any data point, such as a journal entry, a mood score, or a custom metric like "cups of coffee".
            <span class="relative group ml-2">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 text-gray-500 cursor-pointer">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712l-1.848 1.62c-1.172 1.025-1.172 2.687 0 3.712A2.75 2.75 0 0013.5 18.75s-2.25-.5-2.25-2.25a2.25 2.25 0 014.5 0s-2.25.5-2.25 2.25a2.25 2.25 0 014.5 0" />
                </svg>
                <div class="absolute hidden group-hover:block top-8 left-1/2 -translate-x-1/2 w-80 p-4 bg-gray-800 text-white text-sm rounded-lg shadow-lg z-50">
                    <p>Enter the date, a descriptive name for your data (e.g., 'mood' or 'coffee_cups'), and its corresponding value. The value can be a number or text.</p>
                </div>
            </span>
        </p>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="col-span-1">
                <label for="manual-date" class="block text-gray-700 font-semibold mb-2">Date</label>
                <input type="date" id="manual-date" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="col-span-1">
                <label for="manual-key" class="block text-gray-700 font-semibold mb-2">Attribute Name</label>
                <input type="text" id="manual-key" placeholder="e.g., mood, coffee_cups" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="col-span-1">
                <label for="manual-value" class="block text-gray-700 font-semibold mb-2">Value</label>
                <input type="text" id="manual-value" placeholder="e.g., 8 (for mood) or 'great'" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        </div>
        <div class="mt-4">
            <button id="manual-add-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg">Add Data Point</button>
        </div>
    </div>
    
    <div class="card">
        <fieldset class="border-2 border-gray-200 p-4 rounded-lg">
            <legend class="text-2xl font-semibold px-2 mb-4 text-gray-700">2. Manage Your Data Sources</legend>
            <p class="text-gray-600 mb-4">Select one or more data sources to view their data. The 'Manual' source is for entries added by hand.</p>
            
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2 text-gray-700">Select Data Sources</h3>
                <div id="source-checkboxes" class="source-checkbox-container mb-4"></div>
                <button id="delete-source-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg hidden">Delete Source</button>
            </div>

            <div>
                <h3 class="text-lg font-semibold mb-2 text-gray-700">Create a New Data Source</h3>
                <div class="flex flex-col md:flex-row gap-4">
                    <input type="text" id="new-source-name" placeholder="Enter a name for your new source" class="w-full md:w-2/3 bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-green-500">
                    <button id="add-source-btn" class="w-full md:w-1/3 bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 ease-in-out shadow-lg">Create New Source</button>
                </div>
            </div>
        </fieldset>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">3. Upload Data to Current Source</h2>
        <p class="text-gray-600 mb-4">Choose a CSV or JSON file to upload. The first row must be headers, and a 'date' column in YYYY-MM-DD format is required for all data.</p>
        <div class="flex flex-col md:flex-row gap-4">
            <div class="flex-1">
                <label for="file-input" class="block text-gray-700 font-semibold mb-2">Select a File</label>
                <input type="file" id="file-input" accept=".csv, .json" class="w-full text-gray-700 bg-gray-200 rounded-lg p-2 transition duration-300 ease-in-out hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex-1">
                <label for="upload-source-select" class="block text-gray-700 font-semibold mb-2">Select Upload Destination</label>
                <select id="upload-source-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            </div>
        </div>
        <div class="mt-4">
            <button id="upload-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg">Upload Data</button>
        </div>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">4. Your Insights</h2>
        <p class="text-gray-600 mb-4">Select a numerical attribute to visualize trends and find correlations.</p>
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
            <div class="col-span-1 md:col-span-1">
                <label for="key-select" class="block text-gray-700 font-semibold mb-2">Select a data attribute:</label>
                <select id="key-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            </div>
            <div class="col-span-1 md:col-span-1">
                <label for="chart-type-select" class="block text-gray-700 font-semibold mb-2">Chart Type:</label>
                <select id="chart-type-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="line">Line Chart</option>
                    <option value="bar">Bar Chart</option>
                    <option value="scatter">Scatter Plot</option>
                </select>
            </div>
            <div>
                <label for="start-date-filter" class="block text-gray-700 font-semibold mb-2">Start Date</label>
                <input type="date" id="start-date-filter" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div>
                <label for="end-date-filter" class="block text-gray-700 font-semibold mb-2">End Date</label>
                <input type="date" id="end-date-filter" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        </div>
        <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mt-2 mb-4">
            <button id="filter-7-days" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Last 7 Days</button>
            <button id="filter-30-days" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Last 30 Days</button>
            <button id="clear-filter" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Clear</button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 text-center">
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Average</p>
                <p id="stats-avg" class="text-xl font-bold text-blue-800">-</p>
            </div>
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Median</p>
                <p id="stats-median" class="text-xl font-bold text-blue-800">-</p>
            </div>
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Sum</p>
                <p id="stats-sum" class="text-xl font-bold text-blue-800">-</p>
            </div>
        </div>
        
        <div class="mb-4 p-4 rounded-lg bg-gray-50 border border-gray-200" id="correlation-section">
            <h3 class="text-lg font-semibold mb-2">Correlate Data</h3>
            <p class="text-gray-600 mb-4">Note: Correlation is only available for a single data source.</p>
            <div class="flex flex-col md:flex-row gap-4">
                <select id="correlation-key-1" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-purple-500"></select>
                <select id="correlation-key-2" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-purple-500"></select>
                <button id="correlate-btn" class="w-full md:w-auto bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition duration-300 ease-in-out shadow-lg">Run Correlation</button>
            </div>
            <div id="correlation-result" class="mt-2 text-center text-gray-700"></div>
        </div>

        <div class="chart-container">
            <canvas id="data-chart"></canvas>
        </div>
    </div>
    
    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">5. Data Table</h2>
        <div class="table-container">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr id="data-table-header"></tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200" id="data-table-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">6. Manage Your Data</h2>
        <p class="text-gray-600 mb-4">Export your data to a JSON file to create a backup or import a file from another browser to transfer your data.</p>
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4">
            <button id="export-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-lg flex-1">Export All Data</button>
            <div class="flex-1">
                <input type="file" id="import-file-input" accept=".json" class="hidden">
                <button id="import-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-lg w-full">Import Data</button>
            </div>
        </div>
    </div>

</div>

<div id="data-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h2 class="text-xl font-bold mb-4">Data Point Details</h2>
        <p id="modal-read-only-message" class="text-sm text-red-500 mb-2 font-semibold hidden">This is a read-only view. Data from this source cannot be edited.</p>
        <p class="text-sm text-gray-500 mb-2">Source: <strong id="modal-source-display"></strong></p>
        <p class="text-sm text-gray-500 mb-4">Added to database: <span id="modal-created-at"></span></p>

        <div id="modal-custom-data" class="mb-4">
            <h3 class="text-lg font-semibold mb-2">Attributes</h3>
        </div>

        <div class="flex space-x-2" id="modal-buttons-container">
            <button id="modal-save-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg flex-1">Save Changes</button>
            <button id="modal-delete-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg flex-1">Delete Data Point</button>
        </div>
    </div>
</div>

<div id="conflict-modal" class="modal">
    <div class="modal-content">
        <h2 class="text-xl font-bold mb-4">Duplicate Entry Found</h2>
        <p class="mb-4">An entry for <strong id="conflict-date"></strong> already exists in the <strong id="conflict-source"></strong> source. The data is different. Please review the changes before continuing.</p>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div>
                <h3 class="text-lg font-semibold">Existing Data</h3>
                <pre id="existing-data-preview" class="bg-gray-100 p-2 rounded-lg text-sm overflow-x-auto"></pre>
            </div>
            <div>
                <h3 class="text-lg font-semibold">Incoming Data</h3>
                <pre id="incoming-data-preview" class="bg-gray-100 p-2 rounded-lg text-sm overflow-x-auto"></pre>
            </div>
        </div>
        
        <div class="flex space-x-2">
            <button id="overwrite-btn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-300 ease-in-out flex-1">Overwrite</button>
            <button id="skip-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out flex-1">Skip Entry</button>
            <button id="cancel-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition duration-300 ease-in-out flex-1">Cancel Upload</button>
        </div>
    </div>
</div>

<div id="delete-source-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn" id="close-delete-source-modal">&times;</span>
        <h2 class="text-xl font-bold mb-4">Confirm Deletion</h2>
        <p>Are you sure you want to delete the data source: <strong id="delete-source-name"></strong>? This action is permanent and cannot be undone.</p>
        <div class="flex space-x-2 mt-4">
            <button id="confirm-delete-source-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg flex-1">Yes, Delete</button>
            <button id="cancel-delete-source-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out shadow-lg flex-1">Cancel</button>
        </div>
    </div>
</div>

<script>
    // --- Firebase Configuration and Initialization ---
    const firebaseConfig = {
      apiKey: "AIzaSyBL_FesZhiD3JQH8ftmDgTS8HBdVPL1cj8",
      authDomain: "sammy-7298f.firebaseapp.com",
      projectId: "sammy-7298f",
      storageBucket: "sammy-7298f.firebasestorage.app",
      messagingSenderId: "963185683535",
      appId: "1:963185683535:web:807df8941feba46c208e3a",
      measurementId: "G-JT1YF2ELN3"
    };

    // Global variables for Firebase instances and data
    let db, auth;
    let userId;
    let chart;
    let currentDataCache = {};
    let chartDataPoints = [];
    let currentChartKey = '';
    let currentChartType = 'line';
    let availableSources = [];
    let selectedSources = [];
    let sortColumn = 'date';
    let sortDirection = 'desc';

    // Helper function to show a temporary message box
    function showMessage(message, type = 'success', timeout = 3000) {
        const msgBox = document.getElementById('message-box');
        
        // Determine the message box's color based on type
        let colorClass = '';
        if (type === 'error') {
            colorClass = 'bg-red-500';
        } else if (type === 'info') {
            colorClass = 'bg-blue-500';
        } else {
            colorClass = 'bg-green-500';
        }

        msgBox.textContent = message;
        msgBox.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white font-semibold transition-opacity duration-300 opacity-0 ${colorClass}`;
        
        setTimeout(() => {
            msgBox.classList.remove('opacity-0');
        }, 100);

        if (timeout > 0) {
            setTimeout(() => {
                msgBox.classList.add('opacity-0');
            }, timeout);
        }
    }

    /**
     * Initializes Firebase and authenticates the user.
     * This function signs in anonymously.
     */
    async function initFirebase() {
        try {
            const userIdDisplay = document.getElementById('user-id-display');
            userIdDisplay.textContent = 'Signing in...';

            if (!firebaseConfig.projectId) {
                console.error("Firebase config is missing a project ID. Cannot initialize Firebase.");
                userIdDisplay.textContent = 'Configuration Error';
                showMessage("Firebase is not configured. Data will not be saved.", 'error');
                return;
            }

            const app = firebase.initializeApp(firebaseConfig);
            db = firebase.getFirestore(app);
            auth = firebase.getAuth(app);

            firebase.onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = userId;
                    console.log("User signed in with ID:", userId);
                    initDataListeners();
                } else {
                    console.log("No user is signed in.");
                    userIdDisplay.textContent = 'Not signed in';
                    showMessage('Failed to sign in. Please check your Firebase configuration and network connection.', 'error');
                }
            });
            
            await firebase.signInAnonymously(auth);

        } catch (error) {
            console.error("Error initializing Firebase:", error);
            document.getElementById('user-id-display').textContent = 'Error';
            showMessage("Failed to initialize Firebase. Data may not be saved.", 'error');
        }
    }

    /**
     * Initializes data listeners and populates UI elements after successful authentication.
     */
    function initDataListeners() {
        if (!userId) {
            console.error("User ID is not available. Cannot initialize data listeners.");
            return;
        }

        const dataLoadingStatus = document.getElementById('data-loading-status');
        dataLoadingStatus.classList.remove('hidden');

        const sourcesCollectionRef = firebase.collection(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources`);
        firebase.onSnapshot(sourcesCollectionRef, async (snapshot) => {
            dataLoadingStatus.classList.add('hidden');

            const sources = snapshot.docs.map(doc => doc.id);
            availableSources = [...new Set([...sources, 'Manual'])].sort();

            populateSourceCheckboxes(availableSources);
            populateUploadSourceSelector(availableSources);
            
            await handleSourceChange();

        }, (error) => {
            dataLoadingStatus.classList.add('hidden');
            console.error("Error fetching sources:", error);
            showMessage("Failed to load data sources.", 'error');
        });
    }

    /**
     * Stores a data object in Firestore.
     * @param {object} data The data object to store. Must contain 'date' and 'source'.
     */
    async function storeData(data) {
        if (!userId) {
            showMessage("Authentication failed. Please reload the page.", 'error');
            return;
        }
        
        const { date, source, ...attributes } = data;
        if (!date || !source) {
            console.error("Data point is missing date or source:", data);
            return;
        }
        const docRef = firebase.doc(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${source}/dailyData/${date}`);
        const saveButton = document.getElementById('manual-add-btn');
        const spinner = saveButton ? saveButton.querySelector('.spinner') : null;
        if (spinner) spinner.classList.remove('hidden');
        if (saveButton) saveButton.disabled = true;

        try {
            const docSnap = await firebase.getDoc(docRef);
            let existingData = {};
            if (docSnap.exists()) {
                existingData = docSnap.data();
                const mergedData = { ...existingData, ...attributes };
                await firebase.setDoc(docRef, mergedData);
            } else {
                const dataWithTimestamp = { ...attributes, created_at: firebase.serverTimestamp() };
                await firebase.setDoc(docRef, dataWithTimestamp);
            }
            
            console.log("Data stored successfully for date:", date, "and source:", source);
        } catch (error) {
            console.error("Failed to store data:", error);
            showMessage("An error occurred while saving data.", 'error');
        } finally {
            if (spinner) spinner.classList.add('hidden');
            if (saveButton) saveButton.disabled = false;
        }
    }
    
    /**
     * Deletes a data point from Firestore.
     * @param {string} date The date of the data point to delete.
     * @param {string} source The name of the source.
     */
    async function deleteData(date, source) {
        if (!userId) {
            showMessage("Authentication failed. Please reload the page.", 'error');
            return;
        }

        const docRef = firebase.doc(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${source}/dailyData/${date}`);
        try {
            await firebase.deleteDoc(docRef);
            showMessage("Data point deleted successfully!");
        } catch (error) {
            console.error("Failed to delete data:", error);
            showMessage("An error occurred while deleting data.", 'error');
        }
    }
    
    /**
     * Deletes a data source and all its data.
     * @param {string} sourceName The name of the source to delete.
     */
    async function deleteSource(sourceName) {
        if (!userId) {
            showMessage("Authentication failed. Please reload the page.", 'error');
            return;
        }

        const dailyDataCollectionRef = firebase.collection(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${sourceName}/dailyData`);
        const querySnapshot = await firebase.getDocs(dailyDataCollectionRef);
        
        const deletePromises = querySnapshot.docs.map(doc => firebase.deleteDoc(doc.ref));
        await Promise.all(deletePromises);

        const sourceDocRef = firebase.doc(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${sourceName}`);
        await firebase.deleteDoc(sourceDocRef);
    }


    /**
     * Retrieves all unique source names from Firestore.
     * @returns {Promise<Array>} A promise that resolves with an array of unique source names.
     */
    async function getSources() {
        if (!userId) return [];
        const sourcesCollectionRef = firebase.collection(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources`);
        const querySnapshot = await firebase.getDocs(sourcesCollectionRef);
        return querySnapshot.docs.map(doc => doc.id);
    }
    
    /**
     * Retrieves all data from a specific source from Firestore. Caches data locally.
     * @param {string} sourceName The name of the source to retrieve data for.
     * @returns {Promise<Array>} A promise that resolves with an array of all data objects for the given source.
     */
    async function getDataBySource(sourceName) {
        if (!userId) return [];
        if (currentDataCache[sourceName]) {
            return currentDataCache[sourceName];
        }

        const dailyDataCollectionRef = firebase.collection(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${sourceName}/dailyData`);
        const querySnapshot = await firebase.getDocs(dailyDataCollectionRef);
        const data = querySnapshot.docs.map(doc => {
            const data = doc.data();
            const processedData = { ...data, date: doc.id, source: sourceName };
            // Convert Firestore Timestamp to JS Date object
            if (data.created_at && typeof data.created_at.toDate === 'function') {
                processedData.created_at = data.created_at.toDate();
            }
            return processedData;
        });
        currentDataCache[sourceName] = data;
        return data;
    }
    
    /**
     * Retrieves data from a list of selected sources.
     * @param {Array<string>} sourceNames The names of the sources to retrieve data for.
     * @returns {Promise<Array>} A promise that resolves with an array of all data objects from the selected sources.
     */
    async function getCombinedData(sourceNames) {
        if (!userId || !sourceNames || sourceNames.length === 0) return [];
        
        const promises = sourceNames.map(source => getDataBySource(source));
        const results = await Promise.all(promises);
        
        return results.flat();
    }

    /**
     * Retrieves all data from Firestore across all sources.
     * @returns {Promise<Array>} A promise that resolves with an array of all data objects.
     */
    async function getAllData() {
        if (!userId) return [];
        const sources = await getSources();
        let allData = [];
        for (const source of sources) {
            const sourceData = await getDataBySource(source);
            allData = allData.concat(sourceData);
        }
        return allData;
    }

    // --- Data Processing and UI Functions ---

    /**
     * Parses CSV text and converts it into an array of objects, adding the source name.
     * @param {string} text The raw CSV data as a string.
     * @param {string} source The name of the data source.
     * @returns {Array} An array of data objects.
     */
    function parseCSV(text, source) {
        const results = Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            trimHeaders: true,
        });

        if (results.errors.length > 0) {
            console.error("PapaParse errors:", results.errors);
            showMessage("Error parsing CSV. Please check file format.", 'error');
            return null;
        }
        
        const headers = results.meta.fields;
        const lowerCaseHeaders = headers.map(h => h.toLowerCase());
        if (!headers || !lowerCaseHeaders.includes('date')) {
             showMessage("CSV file must contain a 'date' column.", 'error');
             return null;
        }
        
        // Convert numerical strings to numbers and map 'date' column to the doc id
        return results.data.map(row => {
            const processedRow = { source: source };
            for (const key in row) {
                const value = row[key];
                const lowerKey = key.toLowerCase();
                if (lowerKey === 'date') {
                    processedRow.date = value;
                } else if (!isNaN(value) && value !== '') {
                    processedRow[key] = parseFloat(value);
                } else {
                    processedRow[key] = value;
                }
            }
            return processedRow;
        });
    }

    /**
     * Parses JSON text and converts it into an array of objects, adding the source name.
     * @param {string} text The raw JSON data as a string.
     * @param {string} source The name of the data source.
     * @returns {Array} An array of data objects.
     */
    function parseJSON(text, source) {
        try {
            const data = JSON.parse(text);
            if (!Array.isArray(data)) {
                showMessage("Invalid JSON format. Expected an array of objects.", 'error');
                return null;
            }

            const validatedData = data.filter(item => {
                if (!item.date) {
                    console.warn("Skipping JSON object due to missing 'date' field:", item);
                    return false;
                }
                return true;
            });
            
            // Add source to each object and convert numerical strings
            return validatedData.map(item => {
                const processedItem = { ...item, source: source };
                for (const key in processedItem) {
                    const value = processedItem[key];
                    if (typeof value === 'string' && !isNaN(value) && value !== '') {
                        processedItem[key] = parseFloat(value);
                    }
                }
                return processedItem;
            });

        } catch (error) {
            showMessage("Error parsing JSON. Please ensure the file is a valid JSON array.", 'error');
            console.error("JSON parsing error:", error);
            return null;
        }
    }


    /**
     * Populates the source checkboxes for selection.
     */
    function populateSourceCheckboxes(sources) {
        const container = document.getElementById('source-checkboxes');
        container.innerHTML = '';

        if (sources.length === 0) {
            container.innerHTML = '<p class="text-gray-500">No sources available</p>';
            return;
        }
        
        sources.forEach(source => {
            const div = document.createElement('div');
            div.className = 'flex items-center space-x-2';
            div.innerHTML = `
                <input type="checkbox" id="source-${source}" name="source" value="${source}" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                <label for="source-${source}" class="text-gray-700">${source}</label>
            `;
            container.appendChild(div);
        });

        // Add event listeners for new checkboxes
        container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', handleSourceChange);
        });

        // Re-select previously selected sources
        selectedSources.forEach(source => {
            const checkbox = document.getElementById(`source-${source}`);
            if (checkbox) checkbox.checked = true;
        });

        // Default to selecting 'Manual' if no other sources were previously selected
        if (selectedSources.length === 0) {
            const manualCheckbox = document.getElementById('source-Manual');
            if (manualCheckbox) {
                manualCheckbox.checked = true;
                selectedSources = ['Manual'];
            }
        }
    }

    /**
     * Populates the upload source selector with all available sources.
     */
    function populateUploadSourceSelector(sources) {
        const uploadSourceSelect = document.getElementById('upload-source-select');
        uploadSourceSelect.innerHTML = '';

        sources.forEach(source => {
            const option = document.createElement('option');
            option.value = source;
            option.textContent = source;
            uploadSourceSelect.appendChild(option);
        });
    }

    /**
     * Populates the attribute selection dropdown with available keys for the selected source(s).
     */
    async function populateKeySelector() {
        const keySelect = document.getElementById('key-select');
        const corrKey1 = document.getElementById('correlation-key-1');
        const corrKey2 = document.getElementById('correlation-key-2');
        keySelect.innerHTML = '';
        corrKey1.innerHTML = '';
        corrKey2.innerHTML = '';

        if (selectedSources.length === 0) {
            keySelect.innerHTML = '<option value="">No source selected</option>';
            corrKey1.innerHTML = '<option value="">No source selected</option>';
            corrKey2.innerHTML = '<option value="">No source selected</option>';
            return;
        }

        const allData = await getCombinedData(selectedSources);
        
        if (allData.length === 0) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No data available';
            keySelect.appendChild(option);
            corrKey1.appendChild(option.cloneNode(true));
            corrKey2.appendChild(option.cloneNode(true));
            return;
        }

        const allKeys = new Set();
        allData.forEach(item => {
            Object.keys(item).forEach(key => {
                const value = item[key];
                if (key !== 'date' && key !== 'source' && (typeof value === 'number' || value instanceof Date)) {
                    allKeys.add(key);
                }
            });
        });

        const sortedKeys = Array.from(allKeys).sort();
        
        if (sortedKeys.length > 0) {
            sortedKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                keySelect.appendChild(option);
                corrKey1.appendChild(option.cloneNode(true));
                corrKey2.appendChild(option.cloneNode(true));
            });
        } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No numerical data to plot';
            keySelect.appendChild(option);
            corrKey1.appendChild(option.cloneNode(true));
            corrKey2.appendChild(option.cloneNode(true));
        }

        // Keep previous selection if it still exists
        const currentSelectedKey = currentChartKey;
        if (currentSelectedKey && sortedKeys.includes(currentSelectedKey)) {
            keySelect.value = currentSelectedKey;
        } else {
            keySelect.value = sortedKeys[0];
            currentChartKey = sortedKeys[0];
        }
    }

    /**
     * Calculates and displays key statistics for the given data.
     * @param {Array} dataPoints The data points to analyze.
     * @param {string} key The attribute key to analyze.
     */
    function displayStatistics(dataPoints, key) {
        const values = dataPoints.map(item => {
            const value = item[key];
            return (value instanceof Date) ? value.getTime() : parseFloat(value);
        }).filter(v => !isNaN(v));
        
        const statsAvg = document.getElementById('stats-avg');
        const statsMedian = document.getElementById('stats-median');
        const statsSum = document.getElementById('stats-sum');

        if (values.length === 0) {
            statsAvg.textContent = '-';
            statsMedian.textContent = '-';
            statsSum.textContent = '-';
            return;
        }

        const average = values.reduce((sum, val) => sum + val, 0) / values.length;
        statsAvg.textContent = average.toFixed(2);

        const sortedValues = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sortedValues.length / 2);
        const median = sortedValues.length % 2 === 0
            ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
            : sortedValues[mid];
        statsMedian.textContent = median.toFixed(2);
        
        const sum = values.reduce((total, val) => total + val, 0);
        statsSum.textContent = sum.toFixed(2);
    }
    
    /**
     * Calculates the Pearson correlation coefficient between two datasets.
     * @param {Array} data The data points.
     * @param {string} key1 The first attribute key.
     * @param {string} key2 The second attribute key.
     * @returns {number | null} The correlation coefficient or null if data is insufficient.
     */
    function calculateCorrelation(data, key1, key2) {
        const values1 = data.map(item => {
            const value = item[key1];
            return (value instanceof Date) ? value.getTime() : parseFloat(value);
        }).filter(v => !isNaN(v));
        const values2 = data.map(item => {
            const value = item[key2];
            return (value instanceof Date) ? value.getTime() : parseFloat(item[key2]);
        }).filter(v => !isNaN(v));
        
        if (values1.length < 2 || values2.length < 2) return null;

        const avg1 = values1.reduce((sum, val) => sum + val, 0) / values1.length;
        const avg2 = values2.reduce((sum, val) => sum + val, 0) / values2.length;
        
        let numerator = 0;
        let denominator1 = 0;
        let denominator2 = 0;

        for (let i = 0; i < Math.min(values1.length, values2.length); i++) {
            const diff1 = values1[i] - avg1;
            const diff2 = values2[i] - avg2;
            numerator += diff1 * diff2;
            denominator1 += diff1 * diff1;
            denominator2 += diff2 * diff2;
        }

        if (denominator1 * denominator2 === 0) return 0;
        return numerator / Math.sqrt(denominator1 * denominator2);
    }
    
    const chartColors = [
        'rgb(59, 130, 246)',  // blue
        'rgb(16, 185, 129)',  // green
        'rgb(234, 179, 8)',   // yellow
        'rgb(244, 63, 94)',   // rose
        'rgb(124, 58, 237)',  // violet
        'rgb(249, 115, 22)'   // orange
    ];


    /**
     * Renders or updates the chart with data for the selected key(s) from the selected source(s).
     * @param {string} key The attribute key to display on the chart.
     * @param {string} chartType The type of chart to render ('line', 'bar', or 'scatter').
     * @param {string} key2 The second attribute key for a scatter chart.
     */
    async function renderChart(key, chartType = currentChartType, key2 = null) {
        const selectedSources = getSelectedSources();
        const startDate = document.getElementById('start-date-filter').value;
        const endDate = document.getElementById('end-date-filter').value;

        if (!key || selectedSources.length === 0) {
            if (chart) {
                chart.destroy();
                chart = null;
            }
            displayStatistics([], key);
            return;
        }

        try {
            const allData = await getCombinedData(selectedSources);

            const filteredData = allData.filter(item => {
                const itemDate = new Date(item.date);
                const start = startDate ? new Date(startDate) : null;
                const end = endDate ? new Date(endDate) : null;
                return (!start || itemDate >= start) && (!end || itemDate <= end);
            });
            
            chartDataPoints = filteredData;
            
            if (chart) chart.destroy();
            
            // Show/hide correlation section based on chart type and number of sources
            const correlationSection = document.getElementById('correlation-section');
            if (selectedSources.length > 1 || chartType === 'scatter') {
                 correlationSection.style.display = 'none';
            } else {
                 correlationSection.style.display = 'block';
                 if (chartType === 'scatter' || chartType === 'line' || chartType === 'bar') {
                     document.getElementById('correlation-result').textContent = '';
                 }
            }

            let chartConfig;

            if (chartType === 'line' || chartType === 'bar') {
                if (selectedSources.length === 1) {
                    displayStatistics(filteredData, key);
                } else {
                    // Clear stats for multi-source
                    document.getElementById('stats-avg').textContent = '-';
                    document.getElementById('stats-median').textContent = '-';
                    document.getElementById('stats-sum').textContent = '-';
                }

                const datasets = selectedSources.map((source, index) => {
                    const sourceData = filteredData.filter(d => d.source === source);
                    const sortedData = sourceData.sort((a, b) => new Date(a.date) - new Date(b.date));
                    const labels = sortedData.map(item => item.date);
                    const dataValues = sortedData.map(item => {
                        const value = item[key];
                        return (value instanceof Date) ? value.getTime() : (typeof value === 'number' ? value : null);
                    });
                    
                    const color = chartColors[index % chartColors.length];

                    return {
                        label: `${source} - ${key}`,
                        data: dataValues,
                        borderColor: chartType === 'line' ? color : undefined,
                        backgroundColor: chartType === 'line' ? color + '40' : color,
                        tension: chartType === 'line' ? 0.1 : undefined,
                        fill: chartType === 'line' ? true : false,
                        borderWidth: chartType === 'bar' ? 1 : undefined,
                    };
                });
                
                // Combine labels from all sources to get a full date range
                const allLabels = [...new Set(filteredData.map(d => d.date))].sort();

                chartConfig = {
                    type: chartType,
                    data: {
                        labels: allLabels,
                        datasets: datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: handleChartClick,
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'day' },
                                title: { display: true, text: 'Date' }
                            },
                            y: { title: { display: true, text: key } }
                        }
                    }
                };

            } else if (chartType === 'scatter' && key2) {
                if (selectedSources.length > 1) {
                    showMessage("Scatter plots are only available for a single data source.", 'error');
                    return;
                }
                
                const scatterData = filteredData.map(item => ({
                    x: (item[key] instanceof Date) ? item[key].getTime() : parseFloat(item[key]),
                    y: (item[key2] instanceof Date) ? item[key2].getTime() : parseFloat(item[key2])
                })).filter(point => !isNaN(point.x) && !isNaN(point.y));
                
                const correlation = calculateCorrelation(filteredData, key, key2);
                document.getElementById('correlation-result').textContent = correlation !== null 
                    ? `Correlation Coefficient: ${correlation.toFixed(2)}`
                    : 'Not enough data to calculate correlation.';

                chartConfig = {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: `Correlation for ${selectedSources[0]} between ${key} and ${key2}`,
                            data: scatterData,
                            backgroundColor: 'rgb(124, 58, 237)',
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: key }
                            },
                            y: {
                                title: { display: true, text: key2 }
                            }
                        }
                    }
                };
            } else {
                 return; // Do not render if an unknown chart type is selected
            }

            chart = new Chart(document.getElementById('data-chart').getContext('2d'), chartConfig);

        } catch (error) {
            console.error("Error rendering chart:", error);
            showMessage("Failed to render chart data.", 'error');
        }
    }
    
    // Handle chart click to show modal
    function handleChartClick(event) {
        const selectedSources = getSelectedSources();
        if (selectedSources.length > 1) {
            showMessage("Editing is only available when a single source is selected.", 'info');
            return;
        }

        const selectedSource = selectedSources[0];
        const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
        
        if (points.length) {
            const firstPoint = points[0];
            const dataIndex = firstPoint.index;
            const clickedDate = chart.data.labels[dataIndex];
            
            const clickedData = chartDataPoints.find(d => d.date === clickedDate && d.source === selectedSource);
            
            if (clickedData) {
                showModal(clickedData);
            }
        }
    }
    
    // Show data modal
    function showModal(data) {
        const modal = document.getElementById('data-modal');
        const isManualSource = data.source === 'Manual';
        
        document.getElementById('modal-source-display').textContent = data.source;

        // Set modal title and read-only message
        document.getElementById('data-modal').querySelector('h2').textContent = isManualSource ? 'Edit Data Point' : 'Data Point Details';
        document.getElementById('modal-read-only-message').classList.toggle('hidden', isManualSource);

        // Display created_at timestamp
        const createdAt = data.created_at ? new Date(data.created_at).toLocaleString() : 'N/A';
        document.getElementById('modal-created-at').textContent = createdAt;

        const customDataContainer = document.getElementById('modal-custom-data');
        customDataContainer.innerHTML = '';
        Object.keys(data).forEach(key => {
            if (key !== 'date' && key !== 'source' && key !== 'created_at') {
                const div = document.createElement('div');
                div.className = 'mb-2';
                const value = data[key] instanceof Date ? data[key].toISOString() : data[key];
                div.innerHTML = `
                    <label for="modal-${key}" class="block text-gray-700 font-semibold mb-1">${key}</label>
                    <input type="text" id="modal-${key}" value="${value}" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                `;
                customDataContainer.appendChild(div);
            }
        });
        
        // Disable inputs and hide buttons if source is not 'Manual'
        const inputs = customDataContainer.querySelectorAll('input');
        const buttonsContainer = document.getElementById('modal-buttons-container');
        
        if (!isManualSource) {
            inputs.forEach(input => input.disabled = true);
            buttonsContainer.classList.add('hidden');
        } else {
            inputs.forEach(input => input.disabled = false);
            buttonsContainer.classList.remove('hidden');
            document.getElementById('modal-save-btn').onclick = () => saveModalChanges(data.date);
            document.getElementById('modal-delete-btn').onclick = () => deleteModalData(data.date);
        }

        modal.style.display = 'flex';
    }

    // Save changes from the modal
    async function saveModalChanges(date) {
        const selectedSource = getSelectedSources()[0];
        const newAttributes = {};
        const inputs = document.getElementById('modal-custom-data').querySelectorAll('input');
        
        inputs.forEach(input => {
            const key = input.id.replace('modal-', '');
            newAttributes[key] = isNaN(input.value) ? input.value : parseFloat(input.value);
        });

        await storeData({ date, source: selectedSource, ...newAttributes });
        document.getElementById('data-modal').style.display = 'none';
        
        // Clear local cache for the source and re-render
        delete currentDataCache[selectedSource];
        renderChart(currentChartKey, currentChartType);
        renderTable();
    }
    
    // Delete data point from modal
    async function deleteModalData(date) {
        const selectedSource = getSelectedSources()[0];
        if (confirm(`Are you sure you want to delete data for ${date}?`)) {
            await deleteData(date, selectedSource);
            document.getElementById('data-modal').style.display = 'none';
            delete currentDataCache[selectedSource];
            renderChart(currentChartKey, currentChartType);
            renderTable();
        }
    }

    // Close modal function
    function closeModal() {
        document.getElementById('data-modal').style.display = 'none';
    }

    function getSelectedSources() {
        return Array.from(document.querySelectorAll('#source-checkboxes input[type="checkbox"]:checked')).map(cb => cb.value);
    }

    async function handleSourceChange() {
        selectedSources = getSelectedSources();
        
        const deleteSourceBtn = document.getElementById('delete-source-btn');
        if (selectedSources.length === 1 && selectedSources[0] !== 'Manual') {
            deleteSourceBtn.classList.remove('hidden');
        } else {
            deleteSourceBtn.classList.add('hidden');
        }

        await populateKeySelector();
        const firstKey = document.getElementById('key-select').value;
        currentChartKey = firstKey;
        if (firstKey) {
            renderChart(firstKey, currentChartType);
        } else {
            renderChart(null);
        }
        renderTable();
    }
    
    let conflictAction = null;

    async function showConflictModal(row, existingData) {
        const modal = document.getElementById('conflict-modal');
        document.getElementById('conflict-date').textContent = row.date;
        document.getElementById('conflict-source').textContent = row.source;

        // Convert Firestore Timestamp to readable string for preview
        const formattedExistingData = {};
        for (const key in existingData) {
            if (existingData[key] && typeof existingData[key].toDate === 'function') {
                 formattedExistingData[key] = existingData[key].toDate().toLocaleString();
            } else {
                 formattedExistingData[key] = existingData[key];
            }
        }
        
        // Display existing and incoming data separately for comparison
        document.getElementById('existing-data-preview').textContent = JSON.stringify(formattedExistingData, null, 2);
        document.getElementById('incoming-data-preview').textContent = JSON.stringify(row, null, 2);
        
        modal.style.display = 'flex';
        
        return new Promise(resolve => {
            document.getElementById('overwrite-btn').onclick = () => {
                modal.style.display = 'none';
                resolve('overwrite');
            };
            document.getElementById('skip-btn').onclick = () => {
                modal.style.display = 'none';
                resolve('skip');
            };
            document.getElementById('cancel-btn').onclick = () => {
                modal.style.display = 'none';
                resolve('cancel');
            };
        });
    }

    /**
     * Handles file upload, routes to correct parser, and saves data.
     */
    async function handleFileUpload() {
        const fileInput = document.getElementById('file-input');
        const file = fileInput.files[0];
        const source = document.getElementById('upload-source-select').value;
        
        if (!file) {
            showMessage("Please select a file to upload.", 'error');
            return;
        }

        if (!source) {
            showMessage("Please select a data source to upload to.", 'error');
            return;
        }

        let parser;
        if (file.name.toLowerCase().endsWith('.csv')) {
            parser = parseCSV;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            parser = parseJSON;
        } else {
            showMessage("Invalid file type. Please upload a CSV or JSON file.", 'error');
            return;
        }

        const uploadBtn = document.getElementById('upload-btn');
        const originalText = uploadBtn.textContent;
        uploadBtn.textContent = "Processing file...";
        uploadBtn.disabled = true;

        const reader = new FileReader();
        reader.onload = async (e) => {
            const text = e.target.result;
            const data = parser(text, source);
            
            if (!data) {
                uploadBtn.textContent = originalText;
                uploadBtn.disabled = false;
                return;
            }

            try {
                const totalCount = data.length;
                let processedCount = 0;
                let overwrittenCount = 0;
                let skippedCount = 0;
                let newCount = 0;
                conflictAction = null;

                showMessage(`Uploading... 0 of ${totalCount}`, 'info', 0);

                for (const row of data) {
                    const docRef = firebase.doc(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${source}/dailyData/${row.date}`);
                    const docSnap = await firebase.getDoc(docRef);

                    if (docSnap.exists()) {
                        // Conflict detected on the date
                        const existingData = docSnap.data();
                        
                        let isExactMatch = true;
                        const mergedKeys = new Set([...Object.keys(existingData), ...Object.keys(row)]);
                        for (const key of mergedKeys) {
                            if (key !== 'date' && key !== 'source' && JSON.stringify(existingData[key]) !== JSON.stringify(row[key])) {
                                isExactMatch = false;
                                break;
                            }
                        }

                        if (isExactMatch) {
                            skippedCount++;
                        } else {
                            // Data is different, show conflict modal
                            if (conflictAction === null) {
                                uploadBtn.textContent = "Conflict found...";
                                conflictAction = await showConflictModal(row, existingData);
                                uploadBtn.textContent = "Uploading..."; // Reset button text
                            }
                            
                            if (conflictAction === 'overwrite') {
                                const mergedData = { ...existingData, ...row };
                                await firebase.setDoc(docRef, mergedData);
                                overwrittenCount++;
                            } else if (conflictAction === 'skip') {
                                skippedCount++;
                            } else if (conflictAction === 'cancel') {
                                break; // Exit the loop
                            }
                        }
                    } else {
                        // No conflict, store new data with a timestamp
                        const { date, source, ...attributes } = row;
                        const dataWithTimestamp = { ...attributes, created_at: firebase.serverTimestamp() };
                        await firebase.setDoc(docRef, dataWithTimestamp);
                        newCount++;
                    }

                    processedCount++;
                    showMessage(`Uploading... ${processedCount} of ${totalCount}`, 'info', 0);
                }

                // Final summary message
                let finalMessage = `Upload complete! Added ${newCount} new entries.`;
                if (overwrittenCount > 0) {
                    finalMessage += ` Overwrote ${overwrittenCount} entries.`;
                }
                if (skippedCount > 0) {
                    finalMessage += ` Skipped ${skippedCount} entries.`;
                }
                
                showMessage(finalMessage);

                delete currentDataCache[source];
                await populateKeySelector();
                renderChart(currentChartKey, currentChartType);
                renderTable();
            } catch (error) {
                console.error("Error during upload process:", error);
                showMessage("An error occurred during file upload.", 'error');
            } finally {
                uploadBtn.textContent = originalText;
                uploadBtn.disabled = false;
                fileInput.value = null;
            }
        };
        reader.readAsText(file);
    }

    function getCellValue(dataPoint, key) {
        const value = dataPoint[key];
        if (value === null || value === undefined) {
            return { display: '-', title: '' };
        }
        
        let displayValue;
        let titleValue = '';

        if (key === 'date') {
            displayValue = new Date(value).toISOString().slice(0, 10);
            titleValue = value;
        } else if (key === 'created_at') {
            const dateObj = new Date(value);
            displayValue = dateObj.toISOString().slice(0, 10);
            titleValue = dateObj.toLocaleString();
        } else if (typeof value === 'object') {
            displayValue = JSON.stringify(value);
            titleValue = displayValue;
        } else {
            displayValue = value;
            titleValue = value;
        }
        
        return { display: displayValue, title: titleValue };
    }

    function renderTable() {
        const tableBody = document.getElementById('data-table-body');
        const tableHeader = document.getElementById('data-table-header');
        tableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-gray-500 py-4">Loading data...</td></tr>';
        
        getCombinedData(selectedSources).then(allData => {
            if (allData.length === 0) {
                tableHeader.innerHTML = '';
                tableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-gray-500 py-4">No data to display.</td></tr>';
                return;
            }
            
            // Get all unique keys for dynamic headers
            const allKeys = new Set();
            allData.forEach(item => {
                Object.keys(item).forEach(key => allKeys.add(key));
            });
            
            let headers = ['date', 'source', 'created_at', ...Array.from(allKeys).filter(k => k !== 'date' && k !== 'source' && k !== 'created_at').sort()];
            
            // Render table headers
            tableHeader.innerHTML = '';
            headers.forEach(key => {
                const th = document.createElement('th');
                th.textContent = key;
                th.className = 'px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer';
                if (key === sortColumn) {
                    th.innerHTML += ` <span class="text-xs">${sortDirection === 'asc' ? '' : ''}</span>`;
                }
                th.onclick = () => {
                    if (sortColumn === key) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = key;
                        sortDirection = 'asc';
                    }
                    renderTable();
                };
                tableHeader.appendChild(th);
            });
            
            // Sort data
            const sortedData = allData.sort((a, b) => {
                const valA = a[sortColumn];
                const valB = b[sortColumn];

                if (sortColumn === 'date' || sortColumn === 'created_at') {
                     const dateA = new Date(valA);
                     const dateB = new Date(valB);
                     const result = dateA - dateB;
                     return sortDirection === 'asc' ? result : -result;
                }
                
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const result = valA.localeCompare(valB);
                    return sortDirection === 'asc' ? result : -result;
                }
                if (typeof valA === 'number' && typeof valB === 'number') {
                    const result = valA - valB;
                    return sortDirection === 'asc' ? result : -result;
                }
                
                // Fallback for mixed types or missing values
                if (valA === undefined || valA === null) return 1;
                if (valB === undefined || valB === null) return -1;
                return 0;
            });
            
            // Render table body
            tableBody.innerHTML = '';
            sortedData.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                
                headers.forEach(key => {
                    const cell = document.createElement('td');
                    cell.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-800';
                    const { display, title } = getCellValue(item, key);
                    cell.textContent = display;
                    cell.title = title;
                    row.appendChild(cell);
                });
                
                row.onclick = () => showModal(item);
                tableBody.appendChild(row);
            });
        }).catch(error => {
            console.error("Error rendering table:", error);
            tableBody.innerHTML = '<tr><td colspan="100%" class="text-center text-red-500 py-4">Error loading data.</td></tr>';
        });
    }

    // --- Event Listeners ---
    window.addEventListener('DOMContentLoaded', () => {
        initFirebase();
        
        // Manual Data Add
        document.getElementById('manual-add-btn').addEventListener('click', async () => {
            const date = document.getElementById('manual-date').value;
            const key = document.getElementById('manual-key').value;
            const value = document.getElementById('manual-value').value;
            const source = 'Manual';

            if (!date || !key || !value) {
                showMessage("Please fill in all manual data fields.", 'error');
                return;
            }

            const dataToStore = {
                date: date,
                source: source,
                [key]: isNaN(value) ? value : parseFloat(value)
            };
            await storeData(dataToStore);

            document.getElementById('manual-date').value = '';
            document.getElementById('manual-key').value = '';
            document.getElementById('manual-value').value = '';
            delete currentDataCache[source];
            await populateKeySelector();
            renderChart(key, currentChartType);
            renderTable();
            showMessage("Data point added successfully!");
        });

        // Source Management
        document.getElementById('source-checkboxes').addEventListener('change', handleSourceChange);

        document.getElementById('add-source-btn').addEventListener('click', async () => {
            const newSourceName = document.getElementById('new-source-name').value.trim();
            if (!newSourceName) {
                showMessage("Please enter a name for the new source.", 'error');
                return;
            }
            if (!/^[a-zA-Z0-9_-]+$/.test(newSourceName)) {
                 showMessage("Source name can only contain letters, numbers, hyphens, and underscores.", 'error');
                 return;
            }

            const docRef = firebase.doc(db, `artifacts/${firebaseConfig.appId}/users/${userId}/dataSources/${newSourceName}`);
            try {
                await firebase.setDoc(docRef, { created: new Date().toISOString() });
                showMessage(`Source '${newSourceName}' created successfully!`);
                document.getElementById('new-source-name').value = '';
                delete currentDataCache[newSourceName];
                await initDataListeners();
            } catch (error) {
                console.error("Error creating new source:", error);
                showMessage("Failed to create new source.", 'error');
            }
        });

        document.getElementById('delete-source-btn').addEventListener('click', () => {
            const sourceName = getSelectedSources()[0];
            if (sourceName && sourceName !== 'Manual') {
                document.getElementById('delete-source-name').textContent = sourceName;
                document.getElementById('delete-source-modal').style.display = 'flex';
            }
        });

        document.getElementById('confirm-delete-source-btn').addEventListener('click', async () => {
            const sourceName = getSelectedSources()[0];
            if (sourceName && sourceName !== 'Manual') {
                try {
                    await deleteSource(sourceName);
                    showMessage(`Source '${sourceName}' and all its data deleted.`);
                    delete currentDataCache[sourceName];
                    await initDataListeners();
                } catch (error) {
                    console.error("Error deleting source:", error);
                    showMessage("Failed to delete source.", 'error');
                } finally {
                    document.getElementById('delete-source-modal').style.display = 'none';
                }
            }
        });

        document.getElementById('cancel-delete-source-btn').addEventListener('click', () => {
            document.getElementById('delete-source-modal').style.display = 'none';
        });

        // File Upload
        document.getElementById('upload-btn').addEventListener('click', handleFileUpload);
        
        // Charting and Insights
        document.getElementById('key-select').addEventListener('change', (e) => {
            currentChartKey = e.target.value;
            renderChart(currentChartKey, currentChartType);
        });

        document.getElementById('chart-type-select').addEventListener('change', (e) => {
            currentChartType = e.target.value;
            renderChart(currentChartKey, currentChartType);
        });
        
        document.getElementById('correlate-btn').addEventListener('click', () => {
            const key1 = document.getElementById('correlation-key-1').value;
            const key2 = document.getElementById('correlation-key-2').value;
            if (key1 && key2) {
                renderChart(key1, 'scatter', key2);
                document.getElementById('chart-type-select').value = 'scatter';
            } else {
                showMessage("Please select two attributes to correlate.", 'error');
            }
        });

        const startDateInput = document.getElementById('start-date-filter');
        const endDateInput = document.getElementById('end-date-filter');
        startDateInput.addEventListener('change', () => renderChart(currentChartKey, currentChartType));
        endDateInput.addEventListener('change', () => renderChart(currentChartKey, currentChartType));
        
        document.getElementById('filter-7-days').addEventListener('click', () => {
            const today = new Date();
            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setDate(today.getDate() - 7);
            startDateInput.value = sevenDaysAgo.toISOString().slice(0, 10);
            endDateInput.value = today.toISOString().slice(0, 10);
            renderChart(currentChartKey, currentChartType);
        });

        document.getElementById('filter-30-days').addEventListener('click', () => {
            const today = new Date();
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);
            startDateInput.value = thirtyDaysAgo.toISOString().slice(0, 10);
            endDateInput.value = today.toISOString().slice(0, 10);
            renderChart(currentChartKey, currentChartType);
        });

        document.getElementById('clear-filter').addEventListener('click', () => {
            startDateInput.value = '';
            endDateInput.value = '';
            renderChart(currentChartKey, currentChartType);
        });
        
        // Export/Import
        document.getElementById('export-btn').addEventListener('click', async () => {
            const allData = await getAllData();
            if (allData.length === 0) {
                showMessage("No data to export.", 'error');
                return;
            }
            const dataStr = JSON.stringify(allData, (key, value) => {
                if (value instanceof Date) {
                    return value.toISOString();
                }
                return value;
            }, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sammy_export_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage("Data export complete!");
        });

        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file-input').click();
        });

        document.getElementById('import-file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    if (!Array.isArray(importedData)) {
                        showMessage("Invalid import file. Expected a JSON array.", 'error');
                        return;
                    }
                    
                    showMessage(`Importing ${importedData.length} entries...`, 'info', 0);
                    
                    let importedCount = 0;
                    for (const item of importedData) {
                        if (item.date && item.source) {
                            const { created_at, source, ...rest } = item;
                            await storeData({ date: item.date, source: item.source, ...rest });
                            importedCount++;
                        }
                    }

                    showMessage(`Import complete! Added ${importedCount} entries.`, 'success');
                    await initDataListeners();
                } catch (error) {
                    console.error("Error during import:", error);
                    showMessage("Failed to import data. Please ensure the file is a valid JSON array.", 'error');
                } finally {
                    e.target.value = null;
                }
            };
            reader.readAsText(file);
        });

        // Close modal listeners
        document.querySelector('#data-modal .close-btn').addEventListener('click', closeModal);
        window.addEventListener('click', (event) => {
            const dataModal = document.getElementById('data-modal');
            const deleteSourceModal = document.getElementById('delete-source-modal');
            const conflictModal = document.getElementById('conflict-modal');
            
            if (event.target === dataModal) {
                dataModal.style.display = 'none';
            }
            if (event.target === deleteSourceModal) {
                deleteSourceModal.style.display = 'none';
            }
            // Conflict modal should only be closed by button clicks to force a choice
        });
    });
</script>
</body>
</html>
