<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sammy's Lifeblogging & Quantifying Analyser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
            /* Add padding to the body to prevent content from being hidden behind the fixed top-right card */
            padding-top: 1rem;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border-left-color: #2563eb;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .source-checkbox-container {
            max-height: 150px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            background-color: #f8fafc;
        }
        .table-container {
            max-height: 500px;
            overflow: auto;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid #e2e8f0;
            white-space: nowrap;
        }
        th {
            background-color: #f4f6f9;
            color: #4a5568;
            font-weight: 600;
            cursor: pointer;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        tr:hover {
            background-color: #f7fafc;
            cursor: pointer;
        }
        .tag {
            background-color: #e2e8f0;
            color: #4a5568;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 4px;
            margin-bottom: 4px;
            display: inline-block;
        }
        .tag-remove {
            margin-left: 4px;
            cursor: pointer;
        }
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 320px;
            box-shadow: 0 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 10;
            right: 0;
            top: 45px;
            border-radius: 1rem;
            padding: 1rem;
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
        .dropdown-content .card {
            padding: 0;
            box-shadow: none;
            margin: 0;
        }
        .tag-list-container {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-100">

<div id="auth-container" class="container" style="display: none;">
    <div class="card max-w-md mx-auto mt-20">
        <h1 class="text-2xl font-bold text-center mb-6 text-gray-800">Welcome</h1>
        <div class="mb-4">
            <label for="email" class="block text-gray-700 font-semibold mb-2">Email</label>
            <input type="email" id="email" placeholder="you@example.com" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <p id="email-warning" class="text-red-500 text-sm mt-1 hidden">Please enter a valid email address.</p>
        </div>
        <div class="mb-6">
            <label for="password" class="block text-gray-700 font-semibold mb-2">Password</label>
            <input type="password" id="password" placeholder="********" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        <div class="flex flex-col space-y-4">
            <div class="flex space-x-4">
                <button id="sign-up-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg flex-1">Sign Up</button>
                <button id="sign-in-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 ease-in-out shadow-lg flex-1">Log In</button>
            </div>
            <button id="password-reset-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 transition duration-300 ease-in-out shadow-lg w-full">Reset Password</button>
            <button id="google-sign-in-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 transition duration-300 ease-in-out shadow-lg flex-1">
                Sign in with Google
            </button>
            <button id="anonymous-sign-in-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition duration-300 ease-in-out shadow-lg flex-1">
                Continue Anonymously
            </button>
        </div>
    </div>
</div>

<div id="main-app-container" class="container" style="display: none;">
    <div class="flex justify-between items-start mb-10">
        <h1 class="text-4xl font-bold text-gray-800">Sammy's Lifeblogging & Quantifying Analyser</h1>
        <div class="dropdown">
            <button class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-lg flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.982 18.725A7.488 7.488 0 0012 15.75a7.488 7.488 0 00-5.982 2.975m11.963 0a7.488 7.488 0 01-11.963 0m11.963 0A8.966 8.966 0 0112 21a8.966 8.966 0 01-5.982-2.275M15 9.75a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                Manage Account
            </button>
            <div id="manage-account-dropdown" class="dropdown-content">
                <div class="p-4 border border-gray-200 rounded-lg mb-4">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Change Password</h3>
                    <div class="mb-4">
                        <label for="new-password" class="block text-gray-700 font-semibold mb-2">New Password</label>
                        <input type="password" id="new-password" placeholder="Min 6 characters" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="mb-4">
                        <label for="confirm-new-password" class="block text-gray-700 font-semibold mb-2">Confirm New Password</label>
                        <input type="password" id="confirm-new-password" placeholder="********" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <button id="change-password-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg w-full">Change Password</button>
                </div>

                <div class="p-4 border border-gray-200 rounded-lg">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Change Email</h3>
                    <p class="text-sm text-gray-500 mb-4">Note: You may be required to re-authenticate with your current password for this action.</p>
                    <div class="mb-4">
                        <label for="new-email" class="block text-gray-700 font-semibold mb-2">New Email</label>
                        <input type="email" id="new-email" placeholder="new.email@example.com" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <button id="change-email-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg w-full">Change Email</button>
                </div>

                <div class="p-4 border border-gray-200 rounded-lg mt-4">
                    <button id="sign-out-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg w-full">Sign Out</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="card mb-4 p-4 rounded-lg bg-yellow-100 text-yellow-800 text-sm">
        <p>Your unique user ID is: <strong id="user-id-display">Signing in...</strong></p>
        <p>This ID is used to store your data securely and privately in the cloud, allowing you to access it from any device.</p>
    </div>

    <div id="data-loading-status" class="flex items-center justify-center p-4 rounded-lg bg-blue-100 text-blue-800 text-sm mb-4 hidden">
        <div class="spinner mr-3"></div>
        <p id="data-loading-message">Loading data sources...</p>
    </div>

    <div id="message-box" class="fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white font-semibold transition-opacity duration-300 opacity-0" role="alert"></div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">1. Manually Add Data</h2>
        <p class="text-gray-600 mb-4 flex items-center">
            Use this section to add any data point, such as a journal entry, a mood score, or a custom metric like "cups of coffee".
            <span class="relative group ml-2">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 text-gray-500 cursor-pointer">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712l-1.848 1.62c-1.172 1.025-1.172 2.687 0 3.712A2.75 2.75 0 0013.5 18.75s-2.25-.5-2.25-2.25a2.25 2.25 0 014.5 0s-2.25.5-2.25 2.25a2.25 2.25 0 014.5 0" />
                </svg>
                <div class="absolute hidden group-hover:block top-8 left-1/2 -translate-x-1/2 w-80 p-4 bg-gray-800 text-white text-sm rounded-lg shadow-lg z-50">
                    <p>Enter the date, a descriptive name for your data (e.g., 'mood' or 'coffee_cups'), and its corresponding value. The value can be a number or text. You can also add comma-separated tags.</p>
                </div>
            </span>
        </p>
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div class="col-span-1">
                <label for="manual-date" class="block text-gray-700 font-semibold mb-2">Date</label>
                <input type="date" id="manual-date" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="col-span-1">
                <label for="manual-key" class="block text-gray-700 font-semibold mb-2">Attribute Name</label>
                <input type="text" id="manual-key" placeholder="e.g., mood, coffee_cups" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="col-span-1">
                <label for="manual-value" class="block text-gray-700 font-semibold mb-2">Value</label>
                <input type="text" id="manual-value" placeholder="e.g., 8 (for mood) or 'great'" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="col-span-1">
                <label for="manual-tags" class="block text-gray-700 font-semibold mb-2">Tags (comma-separated)</label>
                <input type="text" id="manual-tags" placeholder="e.g., work, personal, meeting" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        </div>
        <div class="mt-4">
            <button id="manual-add-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg">Add Data Point</button>
        </div>
    </div>
    
    <div class="card">
        <fieldset class="border-2 border-gray-200 p-4 rounded-lg">
            <legend class="text-2xl font-semibold px-2 mb-4 text-gray-700">2. Manage Your Data Sources</legend>
            <p class="text-gray-600 mb-4">Select one or more data sources to view their data. The 'Manual' source is for entries added by hand.</p>
            
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-2 text-gray-700">Select Data Sources</h3>
                <div id="source-checkboxes" class="source-checkbox-container mb-4"></div>
                <button id="delete-source-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg hidden">Delete Source</button>
            </div>

            <div>
                <h3 class="text-lg font-semibold mb-2 text-gray-700">Create a New Data Source</h3>
                <div class="flex flex-col md:flex-row gap-4">
                    <input type="text" id="new-source-name" placeholder="Enter a name for your new source" class="w-full md:w-2/3 bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-green-500">
                    <button id="add-source-btn" class="w-full md:w-1/3 bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 ease-in-out shadow-lg">Create New Source</button>
                </div>
            </div>
        </fieldset>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">3. Upload Data to Current Source</h2>
        <p class="text-gray-600 mb-4">Choose a CSV or JSON file to upload. The first row must be headers, and a 'date' column in YYYY-MM-DD format is required for all data.</p>
        <div class="flex flex-col md:flex-row gap-4">
            <div class="flex-1">
                <label for="file-input" class="block text-gray-700 font-semibold mb-2">Select a File</label>
                <input type="file" id="file-input" accept=".csv, .json" class="w-full text-gray-700 bg-gray-200 rounded-lg p-2 transition duration-300 ease-in-out hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex-1">
                <label for="upload-source-select" class="block text-gray-700 font-semibold mb-2">Select Upload Destination</label>
                <select id="upload-source-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            </div>
        </div>
        <div class="mt-4">
            <button id="upload-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg">Upload Data</button>
        </div>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">4. Your Insights</h2>
        <p class="text-gray-600 mb-4">Select a numerical attribute to visualize trends and find correlations.</p>
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
            <div class="col-span-1 md:col-span-1">
                <label for="key-select" class="block text-gray-700 font-semibold mb-2">Select a data attribute:</label>
                <select id="key-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            </div>
            <div class="col-span-1 md:col-span-1">
                <label for="chart-type-select" class="block text-gray-700 font-semibold mb-2">Chart Type:</label>
                <select id="chart-type-select" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="line">Line Chart</option>
                    <option value="bar">Bar Chart</option>
                    <option value="scatter">Scatter Plot</option>
                </select>
            </div>
            <div>
                <label for="start-date-filter" class="block text-gray-700 font-semibold mb-2">Start Date</label>
                <input type="date" id="start-date-filter" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div>
                <label for="end-date-filter" class="block text-gray-700 font-semibold mb-2">End Date</label>
                <input type="date" id="end-date-filter" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        </div>
        <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 mt-2 mb-4">
            <button id="filter-7-days" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Last 7 Days</button>
            <button id="filter-30-days" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Last 30 Days</button>
            <button id="clear-filter" class="bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition duration-300">Clear</button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 text-center">
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Average</p>
                <p id="stats-avg" class="text-xl font-bold text-blue-800">-</p>
            </div>
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Median</p>
                <p id="stats-median" class="text-xl font-bold text-blue-800">-</p>
            </div>
            <div class="bg-blue-100 rounded-lg p-3">
                <p class="text-sm text-gray-600">Sum</p>
                <p id="stats-sum" class="text-xl font-bold text-blue-800">-</p>
            </div>
        </div>
        
        <div class="mb-4 p-4 rounded-lg bg-gray-50 border border-gray-200" id="correlation-section">
            <h3 class="text-lg font-semibold mb-2">Correlate Data</h3>
            <p class="text-gray-600 mb-4">Note: Correlation is only available for a single data source.</p>
            <div class="flex flex-col md:flex-row gap-4">
                <select id="correlation-key-1" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-purple-500"></select>
                <select id="correlation-key-2" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-purple-500"></select>
                <button id="correlate-btn" class="w-full md:w-auto bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition duration-300 ease-in-out shadow-lg">Run Correlation</button>
            </div>
            <div id="correlation-result" class="mt-2 text-center text-gray-700"></div>
        </div>

        <div class="chart-container">
            <canvas id="data-chart"></canvas>
        </div>
    </div>
    
    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">5. Data Table</h2>
        <div class="mb-4">
            <label for="tag-search-input" class="block text-gray-700 font-semibold mb-2">Filter by Tags (comma-separated):</label>
            <input type="text" id="tag-search-input" placeholder="e.g., work, mood" class="w-full bg-gray-200 rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-purple-500">
        </div>
        <div class="table-container">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr id="data-table-header"></tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200" id="data-table-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">6. Manage Tags & Categories</h2>
        <p class="text-gray-600 mb-4">View and manage all tags used across your data points. You can delete a tag to remove it from all associated data.</p>
        <div id="tag-list-container" class="tag-list-container">
            <p id="no-tags-message" class="text-gray-500 text-center py-4">No tags found.</p>
        </div>
    </div>

    <div class="card">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">7. Manage Your Data</h2>
        <p class="text-gray-600 mb-4">Export your data to a JSON file to create a backup or import a file from another browser to transfer your data.</p>
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4">
            <button id="export-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-lg flex-1">Export All Data</button>
            <div class="flex-1">
                <input type="file" id="import-file-input" accept=".json" class="hidden">
                <button id="import-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 ease-in-out shadow-lg w-full">Import Data</button>
            </div>
        </div>
    </div>
</div>


<div id="data-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h2 class="text-xl font-bold mb-4">Data Point Details</h2>
        <p id="modal-read-only-message" class="text-sm text-red-500 mb-2 font-semibold hidden">This is a read-only view. Data attributes from this source cannot be edited.</p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm text-gray-500 mb-4">
            <p>Source: <strong id="modal-source-display"></strong></p>
            <p>File Source: <strong id="modal-file-source-display"></strong></p>
            <p>File Type: <strong id="modal-file-type-display"></strong></p>
            <p>Added by: <strong id="modal-uploaded-by-display"></strong></p>
        </div>
        <p class="text-sm text-gray-500 mb-4">Added to database: <span id="modal-created-at"></span></p>

        <div id="modal-tags-container" class="mb-4">
            <h3 class="text-lg font-semibold mb-2">Tags</h3>
            <div class="flex flex-wrap items-center">
                <input type="text" id="modal-tags-input" placeholder="Add new tag" class="bg-gray-200 rounded-lg p-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div id="modal-tags-list" class="mt-2 flex flex-wrap"></div>
            </div>
        </div>

        <div id="modal-custom-data" class="mb-4">
            <h3 class="text-lg font-semibold mb-2">Attributes</h3>
        </div>

        <div class="flex space-x-2" id="modal-buttons-container">
            <button id="modal-save-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-lg flex-1">Save Changes</button>
            <button id="modal-delete-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg flex-1">Delete Data Point</button>
        </div>
    </div>
</div>

<div id="conflict-modal" class="modal">
    <div class="modal-content">
        <h2 class="text-xl font-bold mb-4">Duplicate Entry Found</h2>
        <p class="mb-4">An entry for <strong id="conflict-date"></strong> already exists in the <strong id="conflict-source"></strong> source. The data is different. Please review the changes before continuing.</p>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div>
                <h3 class="text-lg font-semibold">Existing Data</h3>
                <pre id="existing-data-preview" class="bg-gray-100 p-2 rounded-lg text-sm overflow-x-auto"></pre>
            </div>
            <div>
                <h3 class="text-lg font-semibold">Incoming Data</h3>
                <pre id="incoming-data-preview" class="bg-gray-100 p-2 rounded-lg text-sm overflow-x-auto"></pre>
            </div>
        </div>
        
        <div class="flex space-x-2">
            <button id="overwrite-all-btn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-300 ease-in-out flex-1">Overwrite All</button>
            <button id="overwrite-btn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-300 ease-in-out flex-1">Overwrite</button>
            <button id="skip-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out flex-1">Skip Entry</button>
            <button id="cancel-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition duration-300 ease-in-out flex-1">Cancel Upload</button>
        </div>
    </div>
</div>

<div id="delete-source-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn" id="close-delete-source-modal">&times;</span>
        <h2 class="text-xl font-bold mb-4">Confirm Deletion</h2>
        <p>Are you sure you want to delete the data source: <strong id="delete-source-name"></strong>? This action is permanent and cannot be undone.</p>
        <div class="flex space-x-2 mt-4">
            <button id="confirm-delete-source-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg flex-1">Yes, Delete</button>
            <button id="cancel-delete-source-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out shadow-lg flex-1">Cancel</button>
        </div>
    </div>
</div>

<div id="delete-tag-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn" id="close-delete-tag-modal">&times;</span>
        <h2 class="text-xl font-bold mb-4">Confirm Tag Deletion</h2>
        <p>Are you sure you want to delete the tag: <strong id="delete-tag-name"></strong>? This will remove the tag from all associated data points.</p>
        <div class="flex space-x-2 mt-4">
            <button id="confirm-delete-tag-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 ease-in-out shadow-lg flex-1">Yes, Delete</button>
            <button id="cancel-delete-tag-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out shadow-lg flex-1">Cancel</button>
        </div>
    </div>
</div>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, GoogleAuthProvider, signInWithPopup, updatePassword, updateEmail, signInAnonymously, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, deleteDoc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- Firebase Configuration and Initialization ---
    const firebaseConfig = {
        apiKey: "AIzaSyBL_FesZhiD3JQH8ftmDgTS8HBdVPL1cj8",
        authDomain: "sammy-7298f.firebaseapp.com",
        projectId: "sammy-7298f",
        storageBucket: "sammy-7298f.firebasestorage.app",
        messagingSenderId: "963185683535",
        appId: "1:963185683535:web:807df8941feba46c208e3a",
        measurementId: "G-JT1YF2ELN3"
    };

    // --- IMPORTANT: REPLACE THE ABOVE CONFIGURATION WITH YOUR OWN FIREBASE PROJECT'S DETAILS ---
    // You can find this in your Firebase console under Project Settings.
    
    // Global variables for Firebase instances and data
    let db, auth;
    let userId;
    let chart;
    let currentDataCache = {};
    let chartDataPoints = [];
    let allTags = new Set();
    let currentChartKey = '';
    let currentChartType = 'line';
    let availableSources = [];
    let selectedSources = [];
    let sortColumn = 'date';
    let sortDirection = 'desc';
    let tagFilter = [];

    // Helper function to show a temporary message box
    function showMessage(message, type = 'success', timeout = 3000) {
        const msgBox = document.getElementById('message-box');
        let colorClass = '';
        if (type === 'error') {
            colorClass = 'bg-red-500';
        } else if (type === 'info') {
            colorClass = 'bg-blue-500';
        } else {
            colorClass = 'bg-green-500';
        }
        msgBox.textContent = message;
        msgBox.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white font-semibold transition-opacity duration-300 opacity-0 ${colorClass}`;
        setTimeout(() => {
            msgBox.classList.remove('opacity-0');
        }, 100);
        if (timeout > 0) {
            setTimeout(() => {
                msgBox.classList.add('opacity-0');
            }, timeout);
        }
    }

    /**
     * Helper function for client-side email validation.
     * @param {string} email The email to validate.
     * @returns {boolean} True if the email is valid, false otherwise.
     */
    function isValidEmail(email) {
        const re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        return re.test(String(email).toLowerCase());
    }

    /**
     * Initializes Firebase and authenticates the user.
     * This now uses onAuthStateChanged to handle login state.
     */
    async function initFirebase() {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Listen for changes in the authentication state
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // User is signed in, show the main app
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = user.email || "Anonymous";
                    document.getElementById('auth-container').style.display = 'none';
                    document.getElementById('main-app-container').style.display = 'block';

                    // Setup listener for sources
                    setupSourcesListener();
                } else {
                    // User is signed out
                    userId = null;
                    document.getElementById('auth-container').style.display = 'block';
                    document.getElementById('main-app-container').style.display = 'none';
                    // Clear all data and UI
                    currentDataCache = {};
                    availableSources = [];
                    selectedSources = [];
                    updateSourcesCheckboxes();
                    renderDataTable();
                    renderChart();
                }
            });
        } catch (e) {
            console.error("Error initializing Firebase:", e);
            showMessage("Error initializing the application. Please check your Firebase configuration.", "error", 0);
        }
    }

    // --- Authentication Logic ---

    // Get auth container elements
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const signUpBtn = document.getElementById('sign-up-btn');
    const signInBtn = document.getElementById('sign-in-btn');
    const passwordResetBtn = document.getElementById('password-reset-btn');
    const googleSignInBtn = document.getElementById('google-sign-in-btn');
    const anonymousSignInBtn = document.getElementById('anonymous-sign-in-btn');
    const emailWarning = document.getElementById('email-warning');

    // Get manage account elements
    const newPasswordInput = document.getElementById('new-password');
    const confirmNewPasswordInput = document.getElementById('confirm-new-password');
    const changePasswordBtn = document.getElementById('change-password-btn');
    const newEmailInput = document.getElementById('new-email');
    const changeEmailBtn = document.getElementById('change-email-btn');
    const signOutBtn = document.getElementById('sign-out-btn');

    signUpBtn.addEventListener('click', async () => {
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!isValidEmail(email)) {
            emailWarning.classList.remove('hidden');
            return;
        } else {
            emailWarning.classList.add('hidden');
        }
        try {
            await createUserWithEmailAndPassword(auth, email, password);
            showMessage("Successfully signed up! You are now logged in.");
        } catch (error) {
            showMessage(`Error signing up: ${error.message}`, 'error');
        }
    });

    signInBtn.addEventListener('click', async () => {
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!isValidEmail(email)) {
            emailWarning.classList.remove('hidden');
            return;
        } else {
            emailWarning.classList.add('hidden');
        }
        try {
            await signInWithEmailAndPassword(auth, email, password);
            showMessage("Successfully logged in!");
        } catch (error) {
            showMessage(`Error logging in: ${error.message}`, 'error');
        }
    });

    passwordResetBtn.addEventListener('click', async () => {
        const email = emailInput.value;
        if (!isValidEmail(email)) {
            emailWarning.classList.remove('hidden');
            return;
        } else {
            emailWarning.classList.add('hidden');
        }
        try {
            await sendPasswordResetEmail(auth, email);
            showMessage("Password reset email sent. Please check your inbox.");
        } catch (error) {
            showMessage(`Error sending reset email: ${error.message}`, 'error');
        }
    });

    googleSignInBtn.addEventListener('click', async () => {
        const provider = new GoogleAuthProvider();
        try {
            await signInWithPopup(auth, provider);
            showMessage("Signed in with Google!");
        } catch (error) {
            showMessage(`Error with Google Sign-In: ${error.message}`, 'error');
        }
    });

    anonymousSignInBtn.addEventListener('click', async () => {
        try {
            await signInAnonymously(auth);
            showMessage("Signed in anonymously! Your data will be saved to your device and cloud.");
        } catch (error) {
            showMessage(`Error with anonymous sign-in: ${error.message}`, 'error');
        }
    });

    signOutBtn.addEventListener('click', async () => {
        try {
            await signOut(auth);
            showMessage("Successfully signed out!");
        } catch (error) {
            showMessage(`Error signing out: ${error.message}`, 'error');
        }
    });

    changePasswordBtn.addEventListener('click', async () => {
        const user = auth.currentUser;
        const newPassword = newPasswordInput.value;
        const confirmNewPassword = confirmNewPasswordInput.value;

        if (!user) {
            showMessage("No user is signed in.", "error");
            return;
        }
        if (newPassword !== confirmNewPassword) {
            showMessage("Passwords do not match.", "error");
            return;
        }
        if (newPassword.length < 6) {
            showMessage("Password must be at least 6 characters long.", "error");
            return;
        }

        try {
            await updatePassword(user, newPassword);
            showMessage("Password successfully updated!");
            newPasswordInput.value = '';
            confirmNewPasswordInput.value = '';
        } catch (error) {
            showMessage(`Error updating password: ${error.message}`, 'error');
        }
    });

    changeEmailBtn.addEventListener('click', async () => {
        const user = auth.currentUser;
        const newEmail = newEmailInput.value;

        if (!user) {
            showMessage("No user is signed in.", "error");
            return;
        }
        if (!isValidEmail(newEmail)) {
            showMessage("Please enter a valid email address.", "error");
            return;
        }

        try {
            await updateEmail(user, newEmail);
            showMessage("Email successfully updated! A verification email may be sent to the new address.");
            newEmailInput.value = '';
        } catch (error) {
            showMessage(`Error updating email: ${error.message}`, 'error');
        }
    });

    // --- Data Management Logic ---

    // Get data management elements
    const manualDateInput = document.getElementById('manual-date');
    const manualKeyInput = document.getElementById('manual-key');
    const manualValueInput = document.getElementById('manual-value');
    const manualTagsInput = document.getElementById('manual-tags');
    const manualAddBtn = document.getElementById('manual-add-btn');
    const sourceCheckboxesContainer = document.getElementById('source-checkboxes');
    const deleteSourceBtn = document.getElementById('delete-source-btn');
    const newSourceNameInput = document.getElementById('new-source-name');
    const addSourceBtn = document.getElementById('add-source-btn');
    const fileInput = document.getElementById('file-input');
    const uploadSourceSelect = document.getElementById('upload-source-select');
    const uploadBtn = document.getElementById('upload-btn');
    const dataLoadingStatus = document.getElementById('data-loading-status');
    const dataLoadingMessage = document.getElementById('data-loading-message');

    // Modals
    const dataModal = document.getElementById('data-modal');
    const dataModalCloseBtn = dataModal.querySelector('.close-btn');
    const modalSaveBtn = document.getElementById('modal-save-btn');
    const modalDeleteBtn = document.getElementById('modal-delete-btn');
    let currentDataPointId = null;

    const conflictModal = document.getElementById('conflict-modal');
    const overwriteAllBtn = document.getElementById('overwrite-all-btn');
    const overwriteBtn = document.getElementById('overwrite-btn');
    const skipBtn = document.getElementById('skip-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    let conflictingEntries = null;
    let conflictIndex = 0;
    let totalEntriesToUpload = 0;

    const deleteSourceModal = document.getElementById('delete-source-modal');
    const confirmDeleteSourceBtn = document.getElementById('confirm-delete-source-btn');
    let sourceToDelete = null;

    const deleteTagModal = document.getElementById('delete-tag-modal');
    const confirmDeleteTagBtn = document.getElementById('confirm-delete-tag-btn');
    let tagToDelete = null;
    
    // Set default date
    const today = new Date().toISOString().split('T')[0];
    manualDateInput.value = today;

    /**
     * Updates the data source checkboxes based on the available sources.
     */
    function updateSourcesCheckboxes() {
        sourceCheckboxesContainer.innerHTML = '';
        availableSources.forEach(source => {
            const isSelected = selectedSources.includes(source.id);
            const checkbox = `
                <div class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100 transition duration-150 ease-in-out">
                    <input type="checkbox" id="source-${source.id}" data-source-id="${source.id}" ${isSelected ? 'checked' : ''} class="source-checkbox text-blue-600 focus:ring-blue-500 rounded">
                    <label for="source-${source.id}" class="text-gray-700">${source.name}</label>
                </div>
            `;
            sourceCheckboxesContainer.innerHTML += checkbox;
        });
        
        // Update the delete button visibility
        const isSingleNonManualSourceSelected = selectedSources.length === 1 && selectedSources[0] !== 'manual';
        if (isSingleNonManualSourceSelected) {
            deleteSourceBtn.classList.remove('hidden');
        } else {
            deleteSourceBtn.classList.add('hidden');
        }
    }
    
    // Event listener for source checkboxes
    sourceCheckboxesContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('source-checkbox')) {
            const sourceId = e.target.dataset.sourceId;
            if (e.target.checked) {
                if (!selectedSources.includes(sourceId)) {
                    selectedSources.push(sourceId);
                }
            } else {
                selectedSources = selectedSources.filter(id => id !== sourceId);
            }
            updateSourcesCheckboxes();
            fetchAndRenderData();
        }
    });

    /**
     * Initializes a real-time listener to the user's data sources.
     */
    function setupSourcesListener() {
        if (!userId) return;
        const userDocRef = doc(db, 'users', userId);
        
        onSnapshot(userDocRef, (docSnap) => {
            if (docSnap.exists() && docSnap.data().sources) {
                const sourcesData = docSnap.data().sources;
                availableSources = Object.keys(sourcesData).map(key => ({
                    id: key,
                    name: sourcesData[key].name
                }));
                // Add the default 'manual' source
                availableSources.unshift({ id: 'manual', name: 'Manual' });
                
                // Keep only the selected sources that still exist
                selectedSources = selectedSources.filter(id => availableSources.some(source => source.id === id));
                if (selectedSources.length === 0) {
                    selectedSources.push('manual'); // Select 'manual' by default
                }
                
                updateSourcesCheckboxes();
                updateUploadSourceSelect();
                fetchAndRenderData(); // Call this to fetch data after sources are loaded
            } else {
                // If no sources exist, create the default 'manual' source
                setDoc(userDocRef, { sources: { manual: { name: 'Manual' } } }, { merge: true });
            }
        });
    }

    /**
     * Updates the select dropdown for uploading data.
     */
    function updateUploadSourceSelect() {
        uploadSourceSelect.innerHTML = '';
        availableSources.forEach(source => {
            const option = `<option value="${source.id}">${source.name}</option>`;
            uploadSourceSelect.innerHTML += option;
        });
    }
    
    // Add new source button handler
    addSourceBtn.addEventListener('click', async () => {
        const newSourceName = newSourceNameInput.value.trim();
        if (!newSourceName) {
            showMessage("Source name cannot be empty.", "error");
            return;
        }

        const sourceId = newSourceName.toLowerCase().replace(/\s/g, '-');
        
        try {
            const userDocRef = doc(db, 'users', userId);
            const userDocSnap = await getDoc(userDocRef);
            
            if (userDocSnap.exists() && userDocSnap.data().sources && userDocSnap.data().sources[sourceId]) {
                showMessage("A source with this name already exists.", "error");
                return;
            }
            
            await setDoc(userDocRef, { 
                sources: {
                    [sourceId]: { name: newSourceName }
                }
            }, { merge: true });

            showMessage(`Source '${newSourceName}' created successfully!`);
            newSourceNameInput.value = '';
        } catch (error) {
            showMessage(`Error creating new source: ${error.message}`, 'error');
        }
    });

    // Delete source button handler
    deleteSourceBtn.addEventListener('click', () => {
        if (selectedSources.length !== 1 || selectedSources.includes('manual')) {
            showMessage("Please select exactly one non-manual source to delete.", "error");
            return;
        }
        sourceToDelete = selectedSources[0];
        const sourceName = availableSources.find(s => s.id === sourceToDelete).name;
        document.getElementById('delete-source-name').textContent = sourceName;
        deleteSourceModal.style.display = 'flex';
    });

    confirmDeleteSourceBtn.addEventListener('click', async () => {
        if (!sourceToDelete) return;
        try {
            // Delete the source data points
            const dataCollectionRef = collection(db, 'users', userId, 'data');
            const q = query(dataCollectionRef, where('source', '==', sourceToDelete));
            const querySnapshot = await getDocs(q);
            const deletePromises = querySnapshot.docs.map(doc => deleteDoc(doc.ref));
            await Promise.all(deletePromises);

            // Delete the source from the user document
            const userDocRef = doc(db, 'users', userId);
            const docSnap = await getDoc(userDocRef);
            if (docSnap.exists()) {
                const sources = docSnap.data().sources;
                delete sources[sourceToDelete];
                await setDoc(userDocRef, { sources }, { merge: true });
            }

            showMessage(`Source '${sourceToDelete}' and all its data deleted successfully.`);
            sourceToDelete = null;
            deleteSourceModal.style.display = 'none';
        } catch (error) {
            showMessage(`Error deleting source: ${error.message}`, 'error');
        }
    });

    document.getElementById('close-delete-source-modal').addEventListener('click', () => {
        deleteSourceModal.style.display = 'none';
        sourceToDelete = null;
    });

    // Manual data entry handler
    manualAddBtn.addEventListener('click', async () => {
        const date = manualDateInput.value;
        const key = manualKeyInput.value.trim();
        const value = manualValueInput.value.trim();
        const tags = manualTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');

        if (!date || !key || !value) {
            showMessage("Date, Attribute Name, and Value are required.", "error");
            return;
        }

        try {
            const dataPoint = {
                date,
                [key]: isNaN(Number(value)) ? value : Number(value),
                tags,
                source: 'manual',
                fileSource: 'manual',
                fileType: 'manual',
                createdAt: serverTimestamp()
            };

            const dataCollectionRef = collection(db, 'users', userId, 'data');
            const q = query(dataCollectionRef, where('date', '==', date), where('source', '==', 'manual'));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                // If a manual entry for this date already exists, merge the new data
                const existingDoc = querySnapshot.docs[0];
                const existingData = existingDoc.data();
                const updatedTags = Array.from(new Set([...existingData.tags, ...tags]));
                const updatedData = { ...existingData, ...dataPoint, tags: updatedTags };
                await setDoc(doc(db, 'users', userId, 'data', existingDoc.id), updatedData);
                showMessage("Manual entry for this date updated successfully.");
            } else {
                // No existing entry, add a new one
                const newDocRef = doc(dataCollectionRef);
                await setDoc(newDocRef, dataPoint);
                showMessage("Data point added successfully!");
            }

            // Clear inputs
            manualKeyInput.value = '';
            manualValueInput.value = '';
            manualTagsInput.value = '';
        } catch (error) {
            showMessage(`Error adding data point: ${error.message}`, 'error');
        }
    });

    // File upload handler
    uploadBtn.addEventListener('click', async () => {
        const files = fileInput.files;
        if (files.length === 0) {
            showMessage("Please select a file to upload.", "error");
            return;
        }
        
        const file = files[0];
        const sourceId = uploadSourceSelect.value;
        const fileType = file.name.split('.').pop().toLowerCase();
        
        dataLoadingStatus.classList.add('flex');
        dataLoadingStatus.classList.remove('hidden');
        dataLoadingMessage.textContent = `Uploading data... Preparing file...`;

        try {
            let parsedData = [];
            let headers;
            
            if (fileType === 'csv') {
                const results = await parseCSV(file);
                if (results.errors.length > 0) {
                    throw new Error("Failed to parse CSV file. Please check its format.");
                }
                headers = results.meta.fields;
                parsedData = results.data;
            } else if (fileType === 'json') {
                parsedData = await parseJSON(file);
                if (parsedData.length > 0) {
                    headers = Object.keys(parsedData[0]);
                }
            } else {
                throw new Error("Unsupported file type. Please upload a CSV or JSON file.");
            }

            const dateKey = headers.find(h => h.toLowerCase() === 'date');
            if (!dateKey) {
                throw new Error("The file must contain a 'date' column/key.");
            }
            
            totalEntriesToUpload = parsedData.length;
            
            const dataCollectionRef = collection(db, 'users', userId, 'data');
            const dataPointsToCreate = [];
            conflictingEntries = [];
            
            // First, find all conflicts without doing any writes
            for (const row of parsedData) {
                const date = row[dateKey];
                if (!date) continue; // Skip rows without a date
                
                const q = query(dataCollectionRef, where('date', '==', date), where('source', '==', sourceId));
                const querySnapshot = await getDocs(q);

                const dataPoint = {
                    date,
                    tags: row.tags ? row.tags.split(',').map(t => t.trim()).filter(t => t !== '') : [],
                    source: sourceId,
                    fileSource: file.name,
                    fileType: fileType,
                    createdAt: serverTimestamp(),
                    ...Object.fromEntries(Object.entries(row).filter(([key]) => key.toLowerCase() !== 'date' && key.toLowerCase() !== 'tags'))
                };

                if (!querySnapshot.empty) {
                    // Conflict found, add to buffer
                    conflictingEntries.push({ existingDocRef: querySnapshot.docs[0].ref, existingData: querySnapshot.docs[0].data(), incomingData: dataPoint });
                } else {
                    // No conflict, add to new batch
                    dataPointsToCreate.push(dataPoint);
                }
            }

            // If there are conflicts, handle them via a modal
            if (conflictingEntries.length > 0) {
                // First, upload all non-conflicting data points
                if (dataPointsToCreate.length > 0) {
                    const batch = writeBatch(db);
                    dataPointsToCreate.forEach(dataPoint => {
                        batch.set(doc(dataCollectionRef), dataPoint);
                    });
                    await batch.commit();
                    dataLoadingMessage.textContent = `Uploaded ${dataPointsToCreate.length} new entries. Handling ${conflictingEntries.length} conflicts...`;
                }

                conflictIndex = 0;
                showConflictModal();
            } else {
                // No conflicts, add all to a single batch
                const batch = writeBatch(db);
                dataPointsToCreate.forEach(dataPoint => {
                    batch.set(doc(dataCollectionRef), dataPoint);
                });
                await batch.commit();
                showMessage(`Successfully uploaded ${dataPointsToCreate.length} data points.`);
                
                // Hide loading status after all is done
                dataLoadingStatus.classList.remove('flex');
                dataLoadingStatus.classList.add('hidden');
            }

        } catch (error) {
            showMessage(`Error uploading file: ${error.message}`, 'error', 0);
            dataLoadingStatus.classList.remove('flex');
            dataLoadingStatus.classList.add('hidden');
        }
    });

    function parseCSV(file) {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    resolve(results);
                },
                error: function(err) {
                    reject(err);
                }
            });
        });
    }

    function parseJSON(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    resolve(json);
                } catch (error) {
                    reject(new Error("Failed to parse JSON file."));
                }
            };
            reader.onerror = (err) => {
                reject(err);
            };
            reader.readAsText(file);
        });
    }

    function showConflictModal() {
        if (conflictIndex >= conflictingEntries.length) {
            // No more conflicts to show
            conflictModal.style.display = 'none';
            conflictingEntries = null;
            showMessage("Upload process complete.");
            dataLoadingStatus.classList.remove('flex');
            dataLoadingStatus.classList.add('hidden');
            return;
        }
        
        dataLoadingMessage.textContent = `Uploading data... ${conflictIndex + 1} of ${totalEntriesToUpload} processed...`;

        const conflict = conflictingEntries[conflictIndex];
        document.getElementById('conflict-date').textContent = conflict.incomingData.date;
        const sourceName = availableSources.find(s => s.id === conflict.incomingData.source).name;
        document.getElementById('conflict-source').textContent = sourceName;
        document.getElementById('existing-data-preview').textContent = JSON.stringify(conflict.existingData, null, 2);
        document.getElementById('incoming-data-preview').textContent = JSON.stringify(conflict.incomingData, null, 2);
        
        conflictModal.style.display = 'flex';
    }

    overwriteAllBtn.addEventListener('click', async () => {
        try {
            const batch = writeBatch(db);
            conflictingEntries.forEach(conflict => {
                // Overwrite the existing document with the new data
                batch.set(conflict.existingDocRef, { ...conflict.existingData, ...conflict.incomingData });
            });
            await batch.commit();
            
            showMessage(`Successfully overwrote all ${conflictingEntries.length} conflicting entries.`, 'info');
            conflictModal.style.display = 'none';
            dataLoadingStatus.classList.remove('flex');
            dataLoadingStatus.classList.add('hidden');
            conflictingEntries = null;
        } catch (error) {
            showMessage(`Error overwriting all entries: ${error.message}`, 'error');
            dataLoadingStatus.classList.remove('flex');
            dataLoadingStatus.classList.add('hidden');
        }
    });

    overwriteBtn.addEventListener('click', async () => {
        const conflict = conflictingEntries[conflictIndex];
        try {
            // Overwrite the existing document with the new data
            await setDoc(conflict.existingDocRef, { ...conflict.existingData, ...conflict.incomingData });
            showMessage(`Overwrote entry for ${conflict.incomingData.date}.`, 'info');
        } catch (error) {
            showMessage(`Error overwriting entry: ${error.message}`, 'error');
        }
        
        conflictIndex++;
        showConflictModal();
    });

    skipBtn.addEventListener('click', () => {
        const conflict = conflictingEntries[conflictIndex];
        showMessage(`Skipped entry for ${conflict.incomingData.date}.`, 'info');
        conflictIndex++;
        showConflictModal();
    });
    
    cancelBtn.addEventListener('click', () => {
        conflictModal.style.display = 'none';
        conflictingEntries = null;
        showMessage("Upload cancelled.", 'info');
        dataLoadingStatus.classList.remove('flex');
        dataLoadingStatus.classList.add('hidden');
    });

    /**
     * Fetches data for the selected sources and renders the UI.
     */
    async function fetchAndRenderData() {
        if (!userId) return;

        dataLoadingStatus.classList.add('flex');
        dataLoadingStatus.classList.remove('hidden');
        dataLoadingMessage.textContent = 'Loading data sources...';

        try {
            const dataCollectionRef = collection(db, 'users', userId, 'data');
            const dataCache = {};
            
            if (selectedSources.length > 0) {
                // Fetch data for each selected source
                const fetchPromises = selectedSources.map(sourceId => {
                    const q = query(dataCollectionRef, where('source', '==', sourceId));
                    return getDocs(q).then(querySnapshot => {
                        dataCache[sourceId] = querySnapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                    });
                });
                await Promise.all(fetchPromises);
            }
            
            currentDataCache = dataCache;
            processAllData();
            renderDataTable();
            renderChart();
            renderTagList();
        } catch (error) {
            showMessage(`Error fetching data: ${error.message}`, 'error', 0);
        } finally {
            dataLoadingStatus.classList.remove('flex');
            dataLoadingStatus.classList.add('hidden');
        }
    }

    // --- Charting Logic ---

    const keySelect = document.getElementById('key-select');
    const chartTypeSelect = document.getElementById('chart-type-select');
    const startDateFilter = document.getElementById('start-date-filter');
    const endDateFilter = document.getElementById('end-date-filter');
    const filter7DaysBtn = document.getElementById('filter-7-days');
    const filter30DaysBtn = document.getElementById('filter-30-days');
    const clearFilterBtn = document.getElementById('clear-filter');
    const statsAvg = document.getElementById('stats-avg');
    const statsMedian = document.getElementById('stats-median');
    const statsSum = document.getElementById('stats-sum');
    const correlationSection = document.getElementById('correlation-section');
    const correlationKey1 = document.getElementById('correlation-key-1');
    const correlationKey2 = document.getElementById('correlation-key-2');
    const correlateBtn = document.getElementById('correlate-btn');
    const correlationResult = document.getElementById('correlation-result');
    
    keySelect.addEventListener('change', (e) => {
        currentChartKey = e.target.value;
        renderChart();
    });

    chartTypeSelect.addEventListener('change', (e) => {
        currentChartType = e.target.value;
        renderChart();
    });

    startDateFilter.addEventListener('change', renderChart);
    endDateFilter.addEventListener('change', renderChart);
    filter7DaysBtn.addEventListener('click', () => setDateFilter(7));
    filter30DaysBtn.addEventListener('click', () => setDateFilter(30));
    clearFilterBtn.addEventListener('click', () => setDateFilter(0));

    function setDateFilter(days) {
        const today = new Date();
        endDateFilter.value = today.toISOString().split('T')[0];
        if (days > 0) {
            const pastDate = new Date(today.setDate(today.getDate() - days));
            startDateFilter.value = pastDate.toISOString().split('T')[0];
        } else {
            startDateFilter.value = '';
        }
        renderChart();
    }

    function processAllData() {
        chartDataPoints = [];
        allTags.clear();
        
        let allData = Object.values(currentDataCache).flat();
        
        // Populate key select dropdown and gather all tags
        const keys = new Set();
        allData.forEach(item => {
            Object.keys(item).forEach(key => {
                if (typeof item[key] === 'number') {
                    keys.add(key);
                }
            });
            if (item.tags) {
                item.tags.forEach(tag => allTags.add(tag));
            }
        });
        
        keySelect.innerHTML = '';
        correlationKey1.innerHTML = '';
        correlationKey2.innerHTML = '';
        keys.forEach(key => {
            const option = `<option value="${key}">${key}</option>`;
            keySelect.innerHTML += option;
            correlationKey1.innerHTML += option;
            correlationKey2.innerHTML += option;
        });

        currentChartKey = keySelect.value;
        chartDataPoints = allData;
    }

    function renderChart() {
        if (!currentChartKey || chartDataPoints.length === 0) {
            if (chart) chart.destroy();
            statsAvg.textContent = '-';
            statsMedian.textContent = '-';
            statsSum.textContent = '-';
            return;
        }

        let filteredData = chartDataPoints.filter(item => typeof item[currentChartKey] === 'number');

        // Apply date filters
        const startDate = startDateFilter.value ? new Date(startDateFilter.value) : null;
        const endDate = endDateFilter.value ? new Date(endDateFilter.value) : null;
        if (startDate && endDate) {
            filteredData = filteredData.filter(item => {
                const itemDate = new Date(item.date);
                return itemDate >= startDate && itemDate <= endDate;
            });
        }
        
        // Sort data by date
        filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

        const labels = filteredData.map(item => item.date);
        const data = filteredData.map(item => item[currentChartKey]);
        
        if (chart) {
            chart.destroy();
        }

        const ctx = document.getElementById('data-chart').getContext('2d');
        chart = new Chart(ctx, {
            type: currentChartType,
            data: {
                labels: labels,
                datasets: [{
                    label: currentChartKey,
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day'
                        },
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: currentChartKey
                        }
                    }
                }
            }
        });
        
        // Update statistics
        const numericValues = data.filter(v => typeof v === 'number');
        if (numericValues.length > 0) {
            const sum = numericValues.reduce((a, b) => a + b, 0);
            statsAvg.textContent = (sum / numericValues.length).toFixed(2);
            statsSum.textContent = sum;
            
            const sortedValues = [...numericValues].sort((a, b) => a - b);
            const mid = Math.floor(sortedValues.length / 2);
            if (sortedValues.length % 2 === 0) {
                statsMedian.textContent = ((sortedValues[mid - 1] + sortedValues[mid]) / 2).toFixed(2);
            } else {
                statsMedian.textContent = sortedValues[mid].toFixed(2);
            }
        } else {
            statsAvg.textContent = '-';
            statsMedian.textContent = '-';
            statsSum.textContent = '-';
        }
        
        // Show/hide correlation section
        if (selectedSources.length === 1) {
            correlationSection.classList.remove('hidden');
        } else {
            correlationSection.classList.add('hidden');
            correlationResult.textContent = '';
        }
    }
    
    // Correlation logic
    correlateBtn.addEventListener('click', () => {
        const key1 = correlationKey1.value;
        const key2 = correlationKey2.value;
        
        if (!key1 || !key2) {
            correlationResult.textContent = "Please select two attributes to correlate.";
            return;
        }

        const filteredData = chartDataPoints.filter(item =>
            typeof item[key1] === 'number' && typeof item[key2] === 'number'
        );
        
        if (filteredData.length < 2) {
            correlationResult.textContent = "Not enough data points to calculate correlation.";
            return;
        }

        const x = filteredData.map(item => item[key1]);
        const y = filteredData.map(item => item[key2]);
        
        const n = x.length;
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.map((val, i) => val * y[i]).reduce((a, b) => a + b, 0);
        const sumX2 = x.map(val => val * val).reduce((a, b) => a + b, 0);
        const sumY2 = y.map(val => val * val).reduce((a, b) => a + b, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        
        if (denominator === 0) {
            correlationResult.textContent = "Cannot calculate correlation (no variance).";
            return;
        }
        
        const correlationCoefficient = numerator / denominator;
        
        let resultText = `Correlation between ${key1} and ${key2}: ${correlationCoefficient.toFixed(2)}. `;
        if (correlationCoefficient > 0.7) {
            resultText += "This is a strong positive correlation.";
        } else if (correlationCoefficient > 0.3) {
            resultText += "This is a moderate positive correlation.";
        } else if (correlationCoefficient > -0.3) {
            resultText += "This is a weak or no correlation.";
        } else if (correlationCoefficient > -0.7) {
            resultText += "This is a moderate negative correlation.";
        } else {
            resultText += "This is a strong negative correlation.";
        }
        
        correlationResult.textContent = resultText;
    });

    // --- Data Table Logic ---

    const dataTableBody = document.getElementById('data-table-body');
    const dataTableHeader = document.getElementById('data-table-header');
    const tagSearchInput = document.getElementById('tag-search-input');
    
    tagSearchInput.addEventListener('input', () => {
        tagFilter = tagSearchInput.value.split(',').map(tag => tag.trim().toLowerCase()).filter(tag => tag !== '');
        renderDataTable();
    });

    function renderDataTable() {
        let allData = Object.values(currentDataCache).flat();
        
        // Get all unique headers from all data points
        const headers = new Set(['date', 'source']);
        allData.forEach(item => {
            Object.keys(item).forEach(key => {
                if (!['id', 'createdAt', 'tags', 'source', 'fileSource', 'fileType'].includes(key)) {
                    headers.add(key);
                }
            });
        });
        const headerArray = Array.from(headers).sort();
        headerArray.unshift('date', 'source'); // Ensure date and source are first
        const uniqueHeaderArray = [...new Set(headerArray)];

        // Render table header
        dataTableHeader.innerHTML = '';
        uniqueHeaderArray.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header.charAt(0).toUpperCase() + header.slice(1);
            th.dataset.column = header;
            th.classList.add('cursor-pointer', 'hover:bg-gray-200');
            dataTableHeader.appendChild(th);
        });

        // Add sorting indicator
        const currentSortTh = dataTableHeader.querySelector(`[data-column="${sortColumn}"]`);
        if (currentSortTh) {
            currentSortTh.innerHTML += sortDirection === 'asc' ? ' &uarr;' : ' &darr;';
        }
        
        // Apply tag filter
        let filteredData = allData.filter(item => {
            if (tagFilter.length === 0) return true;
            if (!item.tags) return false;
            return tagFilter.every(tag => item.tags.includes(tag));
        });

        // Apply sorting
        filteredData.sort((a, b) => {
            const valA = a[sortColumn];
            const valB = b[sortColumn];
            
            if (valA === undefined) return 1;
            if (valB === undefined) return -1;

            if (sortDirection === 'asc') {
                if (typeof valA === 'string' && typeof valB === 'string') {
                    return valA.localeCompare(valB);
                }
                return valA - valB;
            } else {
                if (typeof valA === 'string' && typeof valB === 'string') {
                    return valB.localeCompare(valA);
                }
                return valB - valA;
            }
        });

        // Render table body
        dataTableBody.innerHTML = '';
        if (filteredData.length === 0) {
            dataTableBody.innerHTML = `<tr><td colspan="${uniqueHeaderArray.length}" class="text-center text-gray-500 py-4">No data found.</td></tr>`;
            return;
        }

        filteredData.forEach(item => {
            const tr = document.createElement('tr');
            tr.dataset.id = item.id;
            tr.dataset.source = item.source;
            uniqueHeaderArray.forEach(header => {
                const td = document.createElement('td');
                if (header === 'source') {
                    td.textContent = availableSources.find(s => s.id === item.source)?.name || item.source;
                } else if (header === 'tags') {
                    td.innerHTML = (item.tags || []).map(tag => `<span class="tag">${tag}</span>`).join('');
                } else {
                    td.textContent = item[header] !== undefined ? item[header] : '-';
                }
                tr.appendChild(td);
            });
            dataTableBody.appendChild(tr);
        });
    }

    dataTableHeader.addEventListener('click', (e) => {
        const column = e.target.dataset.column;
        if (column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            renderDataTable();
        }
    });

    // Show modal when a row is clicked
    dataTableBody.addEventListener('click', async (e) => {
        const row = e.target.closest('tr');
        if (!row) return;

        const dataId = row.dataset.id;
        const sourceId = row.dataset.source;
        const dataPoint = Object.values(currentDataCache).flat().find(item => item.id === dataId && item.source === sourceId);

        if (!dataPoint) {
            showMessage("Data point not found.", "error");
            return;
        }
        
        currentDataPointId = dataId;
        
        // Populate modal with data
        document.getElementById('modal-source-display').textContent = availableSources.find(s => s.id === dataPoint.source)?.name || dataPoint.source;
        document.getElementById('modal-file-source-display').textContent = dataPoint.fileSource || 'N/A';
        document.getElementById('modal-file-type-display').textContent = dataPoint.fileType || 'N/A';
        document.getElementById('modal-uploaded-by-display').textContent = dataPoint.uploadedBy || 'N/A';
        document.getElementById('modal-created-at').textContent = dataPoint.createdAt ? dataPoint.createdAt.toDate().toLocaleString() : 'N/A';

        // Read-only logic for non-manual sources
        const readOnly = dataPoint.source !== 'manual';
        const modalReadOnlyMessage = document.getElementById('modal-read-only-message');
        const modalTagsInput = document.getElementById('modal-tags-input');
        const modalButtonsContainer = document.getElementById('modal-buttons-container');

        if (readOnly) {
            modalReadOnlyMessage.classList.remove('hidden');
            modalTagsInput.disabled = true;
            modalTagsInput.placeholder = 'Tags from non-manual sources cannot be edited.';
            modalButtonsContainer.classList.add('hidden');
        } else {
            modalReadOnlyMessage.classList.add('hidden');
            modalTagsInput.disabled = false;
            modalTagsInput.placeholder = 'Add new tag';
            modalButtonsContainer.classList.remove('hidden');
        }

        // Populate and update tags
        const modalTagsList = document.getElementById('modal-tags-list');
        modalTagsList.innerHTML = '';
        (dataPoint.tags || []).forEach(tag => {
            modalTagsList.innerHTML += `<span class="tag">${tag} ${!readOnly ? '<span class="tag-remove" data-tag="' + tag + '">&times;</span>' : ''}</span>`;
        });
        
        // Populate custom attributes
        const modalCustomData = document.getElementById('modal-custom-data');
        modalCustomData.innerHTML = '<h3 class="text-lg font-semibold mb-2">Attributes</h3>';
        Object.entries(dataPoint).forEach(([key, value]) => {
            if (!['id', 'createdAt', 'tags', 'source', 'fileSource', 'fileType', 'uploadedBy'].includes(key)) {
                const div = document.createElement('div');
                div.classList.add('mb-2');
                div.innerHTML = `<label for="modal-${key}" class="block text-gray-700 font-semibold mb-1">${key.charAt(0).toUpperCase() + key.slice(1)}</label>`;
                const input = document.createElement('input');
                input.id = `modal-${key}`;
                input.type = typeof value === 'number' ? 'number' : 'text';
                input.value = value;
                input.disabled = readOnly;
                input.classList.add('w-full', 'bg-gray-200', 'rounded-lg', 'p-2', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500');
                div.appendChild(input);
                modalCustomData.appendChild(div);
            }
        });

        // Add event listener for removing tags
        modalTagsList.querySelectorAll('.tag-remove').forEach(tagSpan => {
            tagSpan.addEventListener('click', (e) => {
                const tagToRemove = e.target.dataset.tag;
                dataPoint.tags = dataPoint.tags.filter(t => t !== tagToRemove);
                e.target.closest('.tag').remove();
            });
        });

        dataModal.style.display = 'flex';
    });

    dataModalCloseBtn.addEventListener('click', () => {
        dataModal.style.display = 'none';
    });

    modalSaveBtn.addEventListener('click', async () => {
        const dataPoint = Object.values(currentDataCache).flat().find(item => item.id === currentDataPointId);
        if (!dataPoint || dataPoint.source !== 'manual') {
            showMessage("Cannot save non-manual data points.", "error");
            return;
        }

        try {
            const updatedData = { ...dataPoint };
            
            // Update custom attributes
            const customAttributes = document.getElementById('modal-custom-data').querySelectorAll('input');
            customAttributes.forEach(input => {
                const key = input.id.replace('modal-', '');
                updatedData[key] = input.type === 'number' ? Number(input.value) : input.value;
            });
            
            // Update tags
            const newTagsInput = document.getElementById('modal-tags-input');
            const newTags = newTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
            const existingTags = Array.from(document.getElementById('modal-tags-list').querySelectorAll('.tag')).map(tagSpan => tagSpan.textContent.trim().replace('×', ''));
            updatedData.tags = Array.from(new Set([...existingTags, ...newTags]));

            const docRef = doc(db, 'users', userId, 'data', currentDataPointId);
            await setDoc(docRef, updatedData, { merge: true });

            dataModal.style.display = 'none';
            showMessage("Data point updated successfully!");
        } catch (error) {
            showMessage(`Error saving data: ${error.message}`, 'error');
        }
    });

    modalDeleteBtn.addEventListener('click', async () => {
        if (!currentDataPointId) return;
        
        try {
            const docRef = doc(db, 'users', userId, 'data', currentDataPointId);
            await deleteDoc(docRef);
            dataModal.style.display = 'none';
            showMessage("Data point deleted successfully!");
        } catch (error) {
            showMessage(`Error deleting data: ${error.message}`, 'error');
        }
    });

    // --- Tag Management ---

    const tagListContainer = document.getElementById('tag-list-container');
    const noTagsMessage = document.getElementById('no-tags-message');
    
    function renderTagList() {
        tagListContainer.innerHTML = '';
        if (allTags.size === 0) {
            noTagsMessage.classList.remove('hidden');
        } else {
            noTagsMessage.classList.add('hidden');
            allTags.forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.className = 'tag';
                tagSpan.innerHTML = `${tag} <span class="tag-remove" data-tag="${tag}">&times;</span>`;
                tagListContainer.appendChild(tagSpan);
            });
        }
    }

    tagListContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('tag-remove')) {
            const tag = e.target.dataset.tag;
            tagToDelete = tag;
            document.getElementById('delete-tag-name').textContent = tag;
            deleteTagModal.style.display = 'flex';
        }
    });

    confirmDeleteTagBtn.addEventListener('click', async () => {
        if (!tagToDelete) return;
        try {
            // Find all data points with this tag and remove it
            const dataCollectionRef = collection(db, 'users', userId, 'data');
            const q = query(dataCollectionRef, where('tags', 'array-contains', tagToDelete));
            const querySnapshot = await getDocs(q);

            const batch = writeBatch(db);
            querySnapshot.docs.forEach(docSnap => {
                const currentTags = docSnap.data().tags;
                const updatedTags = currentTags.filter(t => t !== tagToDelete);
                batch.update(docSnap.ref, { tags: updatedTags });
            });
            await batch.commit();

            showMessage(`Tag '${tagToDelete}' and its occurrences have been removed.`);
            deleteTagModal.style.display = 'none';
            tagToDelete = null;
        } catch (error) {
            showMessage(`Error deleting tag: ${error.message}`, 'error');
        }
    });

    document.getElementById('close-delete-tag-modal').addEventListener('click', () => {
        deleteTagModal.style.display = 'none';
        tagToDelete = null;
    });

    // --- Data Export & Import ---
    const exportBtn = document.getElementById('export-btn');
    const importBtn = document.getElementById('import-btn');
    const importFileInput = document.getElementById('import-file-input');
    
    exportBtn.addEventListener('click', async () => {
        try {
            const allData = await fetchAllDataForExport();
            const dataStr = JSON.stringify(allData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sammy_export_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage("Data exported successfully!");
        } catch (error) {
            showMessage(`Error exporting data: ${error.message}`, 'error');
        }
    });
    
    async function fetchAllDataForExport() {
        const dataCollectionRef = collection(db, 'users', userId, 'data');
        const querySnapshot = await getDocs(dataCollectionRef);
        const data = querySnapshot.docs.map(doc => {
            const docData = doc.data();
            const cleanedData = { ...docData };
            // Convert Firestore Timestamp to ISO string for export
            if (cleanedData.createdAt && cleanedData.createdAt.toDate) {
                cleanedData.createdAt = cleanedData.createdAt.toDate().toISOString();
            }
            return cleanedData;
        });
        return { data };
    }

    importBtn.addEventListener('click', () => {
        importFileInput.click();
    });

    importFileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
            const fileContent = await readFileContent(file);
            const importedData = JSON.parse(fileContent);
            
            if (!importedData.data || !Array.isArray(importedData.data)) {
                throw new Error("Invalid import file format. Expected a JSON with a 'data' array.");
            }
            
            if (importedData.data.length === 0) {
                showMessage("No data to import.", 'info');
                return;
            }

            const batch = writeBatch(db);
            const dataCollectionRef = collection(db, 'users', userId, 'data');

            importedData.data.forEach(dataPoint => {
                const newDocRef = doc(dataCollectionRef);
                batch.set(newDocRef, {
                    ...dataPoint,
                    createdAt: serverTimestamp() // Overwrite with new timestamp
                });
            });

            await batch.commit();
            showMessage(`${importedData.data.length} data points imported successfully!`);
        } catch (error) {
            showMessage(`Error importing data: ${error.message}`, 'error', 0);
        }
    });

    function readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (err) => reject(err);
            reader.readAsText(file);
        });
    }

    // --- Initialize App ---
    initFirebase();
</script>
</body>
</html>
