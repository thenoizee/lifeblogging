<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RecipeManagr</title>
    <link rel="icon" href="/favicons/utensils.svg" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
    @media print {
        /* Hide the main app and all modals */
        body > *:not(#print-area) {
            display: none !important;
        }

        /* Ensure the body expands to fit content */
        body, html {
            height: auto !important;
            overflow: visible !important;
            background-color: white !important;
        }

        /* Style the print area */
        #print-area {
            display: block !important;
            position: relative !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            color: black !important;
            background-color: white !important;
            padding: 20px;
        }

        /* Reset Tailwind dark mode specific overrides for print */
        #print-area * {
            color: black !important;
            border-color: #ddd !important;
        }
        
        /* Ensure two columns work on paper */
        .print-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
        }

        /* Timer Button Styles */
.timer-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    background-color: #e0e7ff; /* indigo-100 */
    color: #4338ca; /* indigo-700 */
    padding: 0.1rem 0.5rem;
    border-radius: 9999px;
    font-weight: 600;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid #c7d2fe;
}
.dark .timer-btn {
    background-color: #312e81; /* indigo-900 */
    color: #e0e7ff; /* indigo-100 */
    border-color: #4338ca;
}
.timer-btn:hover {
    background-color: #c7d2fe;
}
.timer-btn.running {
    background-color: #fef3c7; /* amber-100 */
    color: #b45309; /* amber-700 */
    border-color: #fcd34d;
}
.dark .timer-btn.running {
    background-color: #78350f; /* amber-900 */
    color: #fef3c7; /* amber-100 */
    border-color: #d97706;
}
.timer-btn.finished {
    background-color: #fee2e2; /* red-100 */
    color: #b91c1c; /* red-700 */
    border-color: #fca5a5;
    animation: pulse-red 1s infinite;
}
@keyframes pulse-red {
    0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    70% { box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
    100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
}

    }
</style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">

    <header class="bg-white dark:bg-gray-800 shadow-md sticky top-0 z-20">
        <div class="container mx-auto p-4 flex justify-between items-center">
            <h1 class="text-xl md:text-3xl font-bold text-indigo-600 dark:text-indigo-400 flex items-center">
                <i class="fas fa-utensils mr-2 md:mr-3"></i>RecipeManagr
            </h1>
            <div class="flex items-center gap-2 md:gap-4">
                 <div id="options-menu-container" class="relative">
                    <button id="options-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                        <i class="fas fa-cog text-xl"></i>
                    </button>
                    <div id="options-panel" class="hidden absolute right-0 mt-2 w-72 bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 space-y-4 border dark:border-gray-700 z-30">
                        <h4 class="font-bold text-lg">Options</h4>
                        <div class="flex justify-between items-center">
                            <label>Layout</label>
                            <select id="layout-select" class="p-1 border rounded dark:bg-gray-700 dark:border-gray-600 text-sm">
                                <option value="tiles">Tiles</option>
                                <option value="list">List</option>
                            </select>
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="show-images-toggle" class="text-sm">Show Images</label>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" id="show-images-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label for="show-images-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="show-labels-toggle" class="text-sm">Show Labels</label>
                             <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" id="show-labels-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label for="show-labels-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="show-source-toggle" class="text-sm">Show Source</label>
                             <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" id="show-source-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label for="show-source-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="show-description-toggle" class="text-sm">Show Description</label>
                             <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" id="show-description-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label for="show-description-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                        <div class="flex justify-between items-center border-t dark:border-gray-700 pt-4">
                            <label>Sort by</label>
                            <select id="sort-by-select" class="p-1 border rounded dark:bg-gray-700 dark:border-gray-600 text-sm">
                                <option value="title-asc">Title (A-Z)</option>
                                <option value="date-desc">Date Added (Newest)</option>
                                <option value="date-asc">Date Added (Oldest)</option>
                                <option value="rating-desc">Rating (High-Low)</option>
                            </select>
                        </div>
                        <div class="border-t dark:border-gray-700 pt-4">
                             <button id="multi-select-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 text-sm">
                                <i class="fas fa-check-square"></i> Select Multiple Recipes
                            </button>
                        </div>
                         <div class="border-t dark:border-gray-700 pt-4">
                             <button id="shopping-list-mode-btn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 text-sm">
                                <i class="fas fa-shopping-cart"></i> Shopping List Mode
                            </button>
                        </div>
                        <div class="border-t dark:border-gray-700 pt-4">
                            <button id="select-by-label-btn" class="w-full bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                <i class="fas fa-tags"></i> Select all in Label
                            </button>
                        </div>
                        <div class="border-t dark:border-gray-700 pt-4">
                            <button id="manage-appliances-btn" class="w-full bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 text-sm">
                                <i class="fas fa-blender"></i> Manage Appliances
                            </button>
                        </div>
                    </div>
                </div>
                
                <a href="/" class="bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg hover:bg-indigo-700 flex items-center">
                    <i class="fas fa-home md:hidden"></i>
                    <span class="hidden md:inline">Back to Hub</span>
                </a>
                
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <i class="fas fa-moon text-xl"></i>
                </button>
            </div>
        </div>
    </header>

    <div id="app-container" class="container mx-auto p-4">
         <div id="bulk-actions-bar" class="hidden bg-indigo-100 dark:bg-indigo-900 p-2 rounded-lg mb-4 flex justify-between items-center">
            <span id="selection-count">0 recipes selected</span>
            <div>
                 <button id="generate-shopping-list-btn" class="hidden bg-green-500 text-white font-bold py-1 px-3 rounded-lg hover:bg-green-600 text-sm mr-2">Generate Shopping List</button>
                <button id="bulk-delete-btn" class="bg-red-500 text-white font-bold py-1 px-3 rounded-lg hover:bg-red-600 text-sm mr-2">Delete Selected</button>
                <button id="cancel-selection-btn" class="bg-gray-500 text-white font-bold py-1 px-3 rounded-lg hover:bg-gray-600 text-sm">Cancel</button>
            </div>
        </div>

        <div class="mb-6">
            <div class="border-b border-gray-200 dark:border-gray-700">
                <nav class="-mb-px flex justify-between md:justify-start md:space-x-8" aria-label="Tabs">
                    <button id="recipes-tab-btn" class="flex-grow md:flex-grow-0 text-center whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-indigo-600 dark:text-indigo-400 border-indigo-500" data-tab="recipes">
                        Your Recipes
                    </button>
                    <button id="add-recipe-tab-btn" class="flex-grow md:flex-grow-0 text-center whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 border-transparent" data-tab="add-recipe">
                        Add/Edit
                    </button>
                    <button id="timeline-tab-btn" class="flex-grow md:flex-grow-0 text-center whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 border-transparent" data-tab="timeline">
                        Timeline
                    </button>
                </nav>
            </div>
        </div>

        <div id="tab-content-container">
            <div id="recipes-tab-panel">
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
    <div class="flex justify-between items-center mb-2 md:mb-4">
        <h3 class="text-xl font-bold">Filter & Sort</h3>
        <button id="mobile-filter-toggle" class="md:hidden text-indigo-600 dark:text-indigo-400 font-semibold text-sm">
            <i class="fas fa-filter mr-1"></i> Show/Hide
        </button>
    </div>
    
    <div id="filter-container" class="hidden md:grid grid-cols-1 md:grid-cols-5 gap-4">
        <input type="text" id="search-bar" placeholder="ðŸ”Ž Search..." class="w-full p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 md:col-span-2">
        <select id="filter-cuisine" class="p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 w-full"></select>
        <select id="filter-label" class="p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 w-full"></select>
        <select id="filter-rating" class="p-2 border rounded-lg dark:bg-gray-700 dark:border-gray-600 w-full">
            <option value="0">Any Rating</option>
            <option value="1">1+ Stars</option>
            <option value="2">2+ Stars</option>
            <option value="3">3+ Stars</option>
            <option value="4">4+ Stars</option>
            <option value="5">5 Stars</option>
        </select>
        <button id="clear-filters-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 w-full">Clear</button>
    </div>
</div>

                <div>
                    <h2 class="text-2xl font-bold mb-4">Your Recipes</h2>
                    <div id="recipe-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
                </div>
            </div>

            <div id="add-recipe-tab-panel" class="hidden">
                 <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
                    <h2 class="text-2xl font-bold mb-4">Import Recipes</h2>
                     <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1">Import from RecipeSage TXT URL</label>
                            <div class="flex flex-col md:flex-row gap-2">
                                <input type="url" id="import-txt-url-input" placeholder="Enter RecipeSage TXT export URL" class="flex-grow p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <button id="fetch-txt-url-btn" type="button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Fetch TXT</button>
                            </div>
                        </div>
                        <div class="text-center text-sm font-semibold">OR</div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Import from URL (JSON-LD)</label>
                            <div id="import-form" class="flex flex-col md:flex-row gap-2">
                                <input type="url" id="import-url-input" placeholder="Enter recipe URL" class="flex-grow p-2 border rounded dark:bg-gray-700 dark:border-gray-600" required>
                                <button id="fetch-url-btn" type="button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Fetch JSON-LD</button>
                            </div>
                        </div>
                        <div class="text-center text-sm font-semibold">OR</div>
                        <div>
                            <label for="import-file-input" class="block text-sm font-medium mb-1">Import from File (.txt or .jsonld)</label>
                            <input type="file" id="import-file-input" accept=".txt,.jsonld,.json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                        </div>
                    </div>
                    <div id="import-review-section" class="hidden mt-4 p-4 border-t dark:border-gray-700">
                        <p id="import-summary-text" class="font-semibold mb-4"></p>
                        <div class="flex flex-col md:flex-row gap-2">
                             <button id="batch-import-btn" type="button" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 flex items-center justify-center">
                                <i class="fas fa-file-import mr-2"></i> Import All Recipes
                            </button>
                             <button id="load-first-recipe-btn" type="button" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 flex items-center justify-center">
                                <i class="fas fa-edit mr-2"></i> Load First Recipe in Editor
                            </button>
                        </div>
                    </div>
                </div>
                 <div id="add-recipe-container" class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
                    <h2 id="form-summary" class="text-2xl font-bold">Add a New Recipe</h2>
                    <form id="add-recipe-form" class="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="lg:col-span-3 bg-indigo-50 dark:bg-indigo-900/30 p-3 rounded-lg border border-indigo-100 dark:border-indigo-800 mb-2">
    <label class="flex items-center space-x-2 cursor-pointer">
        <input type="checkbox" id="is-food-item-toggle" class="rounded text-indigo-600 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 w-5 h-5">
        <span class="font-bold text-indigo-900 dark:text-indigo-200">Ingredient/Food Mode</span>
    </label>
    <p class="text-xs text-indigo-700 dark:text-indigo-300 ml-7 mt-1">Enable this to create a food item (made of specific quantities of ingredients) without instructions or cooking times.</p>
</div>
                        <div class="lg:col-span-3">
                            <label for="recipe-name" class="block text-sm font-medium mb-1">Title</label>
                            <input type="text" id="recipe-name" placeholder="e.g., Spicy Chicken Curry" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div class="lg:col-span-3">
                            <label for="recipe-description" class="block text-sm font-medium mb-1">Description</label>
                            <textarea id="recipe-description" placeholder="A short summary of the dish" rows="3" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full"></textarea>
                        </div>
                        <div>
                            <label for="recipe-cuisine" class="block text-sm font-medium mb-1">Cuisine</label>
                            <input type="text" id="recipe-cuisine" placeholder="e.g., Italian" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div>
                             <label class="block text-sm font-medium mb-1">Yield</label>
                            <div class="flex gap-2">
                                <input type="number" id="recipe-yield-quantity" placeholder="Quantity" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-1/2">
                                <select id="recipe-yield-unit" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-1/2">
                                    <optgroup label="Portions"><option>servings</option><option>small servings</option><option>regular servings</option><option>large servings</option><option>child portions</option><option>adult portions</option></optgroup>
                                    <optgroup label="Items"><option>items</option><option>pieces</option><option>cookies</option><option>muffins</option><option>pancakes</option><option>skewers</option><option>pie</option><option>pudding</option><option>bag</option><option>cut (thin)</option><option>cut (medium)</option><option>cut (thick)</option></optgroup>
                                    <optgroup label="Containers"><option>container</option><option>plates</option><option>bowls</option><option>glasses</option><option>scoops</option><option>bowl-fuls</option></optgroup>
                                    <optgroup label="Weights/Volumes"><option>grams (g)</option><option>kilograms (kg)</option><option>ounces (oz)</option><option>pounds (lb)</option><option>cup</option></optgroup>
                                </select>
                            </div>
                        </div>
                        <div>
                            <label for="recipe-prep-time" class="block text-sm font-medium mb-1">Prep Time (mins)</label>
                            <input type="number" id="recipe-prep-time" placeholder="e.g., 15" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div>
                            <label for="recipe-cook-time" class="block text-sm font-medium mb-1">Cook Time (mins)</label>
                            <input type="number" id="recipe-cook-time" placeholder="e.g., 30" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div>
    <label for="recipe-resting-time" class="block text-sm font-medium mb-1">Resting Time (mins)</label>
    <input type="number" id="recipe-resting-time" placeholder="e.g., 10" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
</div>
                        <div>
                             <label for="recipe-total-time" class="block text-sm font-medium mb-1">Total Time (mins)</label>
                            <input type="number" id="recipe-total-time" placeholder="e.g., 45" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                         <div>
                            <label for="recipe-discovered-date" class="block text-sm font-medium mb-1">Date Discovered</label>
                            <input type="date" id="recipe-discovered-date" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div class="lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="recipe-source-name" class="block text-sm font-medium mb-1">Source Name</label>
                                <input type="text" id="recipe-source-name" placeholder="e.g., Chetna Makan" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                            </div>
                             <div>
                                <label for="recipe-source-url" class="block text-sm font-medium mb-1">Source URL</label>
                                <input type="text" id="recipe-source-url" placeholder="https://..." class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                            </div>
                        </div>
                        <div class="lg:col-span-3">
                            <label class="flex items-center gap-2 text-sm mb-1">
                                Ingredients 
                                <i class="fas fa-info-circle text-gray-400" title="Use [Section Name] for headings and ## for inline tips."></i>
                            </label>
                            <textarea id="recipe-ingredients" placeholder="e.g., [Sauce]&#10;1 cup tomatoes ## fresh is best" rows="5" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full"></textarea>
                        </div>
                        <div class="lg:col-span-3">
    <label class="flex items-center gap-2 text-sm mb-2">
        Instructions
        <i class="fas fa-info-circle text-gray-400" title="Add steps and optional timers."></i>
    </label>
    
    <div id="instructions-builder" class="space-y-2 mb-2">
        </div>

    <div class="flex gap-2">
        <button type="button" id="add-step-btn" class="text-sm bg-indigo-50 text-indigo-700 border border-indigo-200 py-1 px-3 rounded hover:bg-indigo-100">
            <i class="fas fa-plus"></i> Add Step
        </button>
        <button type="button" id="add-section-btn" class="text-sm bg-gray-50 text-gray-700 border border-gray-200 py-1 px-3 rounded hover:bg-gray-100">
            <i class="fas fa-heading"></i> Add Section
        </button>
    </div>
</div>
                        <div class="lg:col-span-3">
                            <label for="recipe-notes" class="block text-sm font-medium mb-1">General Notes</label>
                            <textarea id="recipe-notes" placeholder="Any other notes about this recipe" rows="3" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full"></textarea>
                        </div>
                         <div class="lg:col-span-3">
                            <label for="linked-recipes-select" class="block text-sm font-medium mb-1">Linked Recipes</label>
                            <select id="linked-recipes-select" multiple class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full h-24"></select>
                        </div>
                        <div>
                            <label for="recipe-labels" class="block text-sm font-medium mb-1">Labels</label>
                            <input type="text" id="recipe-labels" placeholder="e.g., quick, spicy, vegan" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                        </div>
                        <div>
                             <label for="recipe-meal-type" class="block text-sm font-medium mb-1">Meal Type</label>
                            <select id="recipe-meal-type" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                                <option value="">Select Meal Type</option>
                                <option>Breakfast</option><option>Lunch</option><option>Dinner</option><option>Snack</option><option>Dessert</option>
                            </select>
                        </div>
                        <div>
                             <label for="recipe-category" class="block text-sm font-medium mb-1">Category</label>
                            <select id="recipe-category" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                                <option value="">Select Category</option>
                                <option>Food</option><option>Drink</option>
                            </select>
                        </div>
                        <div class="lg:col-span-3">
    <label class="block text-sm font-medium mb-1">Flavor Profile</label>
    <div class="flex gap-4">
        <label class="flex items-center space-x-2 cursor-pointer">
            <input type="checkbox" id="flavor-sweet" class="rounded text-indigo-600 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600">
            <span>Sweet</span>
        </label>
        <label class="flex items-center space-x-2 cursor-pointer">
            <input type="checkbox" id="flavor-savoury" class="rounded text-indigo-600 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600">
            <span>Savoury</span>
        </label>
    </div>
</div>
                        <div>
                            <label for="recipe-image-upload" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Recipe Image</label>
                            <div class="flex items-center gap-4">
                                <input type="file" id="recipe-image-upload" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                                <img id="image-preview" src="" alt="Image Preview" class="w-16 h-16 object-cover rounded-md hidden">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Initial Rating</label>
                            <div id="add-recipe-rating" class="flex items-center gap-1"></div>
                        </div>
                        <div id="form-buttons" class="lg:col-span-3 flex gap-4">
                            <button id="add-recipe-btn" type="button" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Add Recipe</button>
                        </div>
                    </form>
                </div>
            </div>

            <div id="timeline-tab-panel" class="hidden">
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-bold mb-4">Recipe Timeline</h2>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mb-6">A chronological history of every time you've cooked a recipe.</p>
                    <div id="timeline-container" class="space-y-8"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="recipe-detail-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden items-center justify-center p-4"></div>
    <div id="history-modal-container" class="fixed inset-0 bg-black bg-opacity-75 z-[60] hidden items-center justify-center p-4"></div>
    <div id="appliances-modal-container" class="fixed inset-0 bg-black bg-opacity-75 z-[60] hidden items-center justify-center p-4"></div>
    <div id="next-import-modal" class="fixed inset-0 bg-black bg-opacity-75 z-[60] hidden items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl w-full max-w-md p-6">
            <h3 class="text-xl font-bold mb-4">Recipe Saved!</h3>
            <p id="next-import-prompt-text" class="mb-6"></p>
            <div class="flex gap-4">
                <button id="next-import-confirm-btn" class="flex-grow bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Load Next</button>
                <button id="next-import-cancel-btn" class="flex-grow bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="print-area" class="hidden"></div>

    <div id="notification-container" class="fixed top-5 right-5 z-[100] w-full max-w-sm space-y-2"></div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, doc, query, orderBy, serverTimestamp, updateDoc, deleteDoc, limit, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyBL_FesZhiD3JQH8ftmDgTS8HBdVPL1cj8",
            authDomain: "sammy-7298f.firebaseapp.com",
            projectId: "sammy-7298f",
            storageBucket: "sammy-7298f.appspot.com",
            messagingSenderId: "963185683535",
            appId: "1:963185683535:web:807df8941feba46c208e3a",
            measurementId: "G-JT1YF2ELN3"
        };
        
        const CONVERSIONS = {
            TSP_TO_ML: { 'us_customary': 4.92892, 'metric': 5 },
            TBSP_TO_ML: { 'us_customary': 14.7868, 'uk_metric': 15, 'au_metric': 20 },
            CUP_TO_ML: { 'us_customary': 236.59, 'metric': 250 },
            G_TO_OZ: 0.035274,
            OZ_TO_G: 28.3495,
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const storage = getStorage(app);

        let userId = null;
        let recipesCache = [];
        let appliancesCache = [];
        let currentRating = 0;
        let editingRecipeId = null;
        let importedImageUrl = null;
        let fetchedRecipesCache = [];
        let currentLayout = 'tiles';
        let currentSort = 'title-asc';
        let displayOptions = {
            showImages: true,
            showLabels: true,
            showSource: false,
            showDescription: false,
        };
        let isMultiSelectMode = false;
        let isShoppingListMode = false;
        let selectedRecipeIds = new Set();
        
        document.addEventListener('DOMContentLoaded', () => {
            const recipeList = document.getElementById('recipe-list');
            const addRecipeBtn = document.getElementById('add-recipe-btn');
            const themeToggle = document.getElementById('theme-toggle');
            const searchBar = document.getElementById('search-bar');
            const modalContainer = document.getElementById('recipe-detail-modal');
            const historyModalContainer = document.getElementById('history-modal-container');
            const appliancesModalContainer = document.getElementById('appliances-modal-container');
            const nextImportModalEl = document.getElementById('next-import-modal');
            const form = document.getElementById('add-recipe-form');
            const filterCuisine = document.getElementById('filter-cuisine');
            const filterLabel = document.getElementById('filter-label');
            const filterRating = document.getElementById('filter-rating');
            const clearFiltersBtn = document.getElementById('clear-filters-btn');
            const optionsBtn = document.getElementById('options-btn');
            const optionsPanel = document.getElementById('options-panel');
            const layoutSelect = document.getElementById('layout-select');
            const sortBySelect = document.getElementById('sort-by-select');
            const multiSelectBtn = document.getElementById('multi-select-btn');
            const appContainer = document.getElementById('app-container');
            const bulkActionsBar = document.getElementById('bulk-actions-bar');
            const selectionCountEl = document.getElementById('selection-count');
            const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
            const cancelSelectionBtn = document.getElementById('cancel-selection-btn');
            const shoppingListModeBtn = document.getElementById('shopping-list-mode-btn');
            const generateShoppingListBtn = document.getElementById('generate-shopping-list-btn');
            const manageAppliancesBtn = document.getElementById('manage-appliances-btn');
            const fetchUrlBtn = document.getElementById('fetch-url-btn');
            const fetchTxtUrlBtn = document.getElementById('fetch-txt-url-btn');
            const importReviewSection = document.getElementById('import-review-section');
            const batchImportBtn = document.getElementById('batch-import-btn');
            const loadFirstRecipeBtn = document.getElementById('load-first-recipe-btn');
            const importSummaryText = document.getElementById('import-summary-text');
            const importFileInput = document.getElementById('import-file-input');
            const timelineContainer = document.getElementById('timeline-container');
            const mobileFilterToggle = document.getElementById('mobile-filter-toggle');
            const filterContainer = document.getElementById('filter-container');

const foodModeToggle = document.getElementById('is-food-item-toggle');
foodModeToggle.addEventListener('change', (e) => {
    const isFood = e.target.checked;
    const fieldsToHide = [
        'recipe-prep-time', 'recipe-cook-time', 'recipe-resting-time', 'recipe-total-time',
        'instructions-builder', 'add-step-btn', 'add-section-btn'
    ];
    
    fieldsToHide.forEach(id => {
        const el = document.getElementById(id);
        if(el) {
            // Hide the input and its parent label/container if possible, or just the input
            const container = el.closest('div'); 
            if(container && !container.classList.contains('lg:col-span-3')) {
                 // Hide specific time inputs containers
                 container.style.display = isFood ? 'none' : 'block';
            } else if (id === 'instructions-builder' || id.includes('btn')) {
                 // Hide instructions area buttons
                 el.parentElement.style.display = isFood ? 'none' : 'block';
            }
        }
    });
    
    // Explicitly handle instructions label
    const instrLabel = document.querySelector('label[for="instructions-builder"]') || 
                       [...document.querySelectorAll('label')].find(l => l.textContent.includes('Instructions'));
    if(instrLabel) instrLabel.parentElement.style.display = isFood ? 'none' : 'block';
});


            // Instruction Builder Listeners
    document.getElementById('add-step-btn').addEventListener('click', () => {
        document.getElementById('instructions-builder').appendChild(createInstructionRow());
    });
    
    document.getElementById('add-section-btn').addEventListener('click', () => {
        document.getElementById('instructions-builder').appendChild(createSectionRow());
    });

            if (mobileFilterToggle) {
        mobileFilterToggle.addEventListener('click', () => {
            filterContainer.classList.toggle('hidden');
        });
    }
            
            // Tab Elements
            const recipesTabBtn = document.getElementById('recipes-tab-btn');
            const addRecipeTabBtn = document.getElementById('add-recipe-tab-btn');
            const timelineTabBtn = document.getElementById('timeline-tab-btn');
            const recipesTabPanel = document.getElementById('recipes-tab-panel');
            const addRecipeTabPanel = document.getElementById('add-recipe-tab-panel');
            const timelineTabPanel = document.getElementById('timeline-tab-panel');
            const formSummary = document.getElementById('form-summary');

            function showNotification(message, type = 'success') {
                const container = document.getElementById('notification-container');
                const notification = document.createElement('div');
                const bgColor = type === 'success' ? 'bg-green-500' : (type === 'error' ? 'bg-red-500' : 'bg-blue-500');
                notification.className = `p-4 rounded-lg text-white ${bgColor} shadow-lg animate-pulse`;
                notification.textContent = message;
                container.appendChild(notification);
                setTimeout(() => {
                    notification.classList.remove('animate-pulse');
                    setTimeout(() => {
                        notification.remove();
                    }, 3000);
                }, 500);
            }

            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeToggle.innerHTML = '<i class="fas fa-sun text-xl"></i>';
                } else {
                    document.documentElement.classList.remove('dark');
                    themeToggle.innerHTML = '<i class="fas fa-moon text-xl"></i>';
                }
            };

            function createSafeKey(str) {
                    if (typeof str !== 'string') return '';
                    return str.replace(/[.$#[\]/]/g, '_');
                }

                 const renderNote = (note) => note ? `<div class="mt-1 p-2 bg-yellow-100 dark:bg-yellow-900/50 text-yellow-800 dark:text-yellow-200 rounded-md text-xs italic cursor-pointer"><i class="fas fa-thumbtack mr-2"></i>${note}</div>` : '';
            
            const processData = (data, defaultSectionName) => {
                if (!data) return [];
                let sections;

                if (typeof data === 'string') {
                    sections = parseSections(data);
                } else if (Array.isArray(data)) {
                    if (data.length === 0) return [];
                    if (typeof data[0] === 'object' && data[0] !== null && 'items' in data[0]) {
                        sections = data;
                    } else { // Handle flat array of strings by parsing for sections
                        const parsedFromFlatArray = [];
                        let currentSectionForFlatArray = { section: defaultSectionName, items: [] };
                        data.forEach(line => {
                            const match = line.trim().match(/^\[(.*?)\]:?$/);
                            if (match && line.trim().endsWith(']')) {
                                if (currentSectionForFlatArray.items.length > 0) {
                                    parsedFromFlatArray.push(currentSectionForFlatArray);
                                }
                                currentSectionForFlatArray = { section: match[1].trim(), items: [] };
                            } else {
                                currentSectionForFlatArray.items.push(line);
                            }
                        });
                        if (currentSectionForFlatArray.items.length > 0 || parsedFromFlatArray.length === 0) {
                            parsedFromFlatArray.push(currentSectionForFlatArray);
                        }
                        sections = parsedFromFlatArray;
                    }
                } else {
                    return [];
                }

                // Normalize items to ensure they are objects with a .text property
                return sections.map(section => {
                    if (!section || !Array.isArray(section.items)) {
                        return { section: (section && section.section) || defaultSectionName, items: [] };
                    }
                    const normalizedItems = section.items.map(item => {
                        if (typeof item === 'string') {
                            return { text: item };
                        }
                        if (typeof item === 'object' && item !== null && typeof item.text === 'string') {
                            return item;
                        }
                        return null; 
                    }).filter(Boolean);

                    return {
                        section: section.section,
                        items: normalizedItems
                    };
                });
            };


            function switchTab(tabName) {
                const tabs = [
                    { btn: recipesTabBtn, panel: recipesTabPanel },
                    { btn: addRecipeTabBtn, panel: addRecipeTabPanel },
                    { btn: timelineTabBtn, panel: timelineTabPanel }
                ];

                tabs.forEach(tab => {
                    if (tab.btn.dataset.tab === tabName) {
                        tab.panel.classList.remove('hidden');
                        tab.btn.classList.add('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-500');
                        tab.btn.classList.remove('text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200', 'border-transparent');
                    } else {
                        tab.panel.classList.add('hidden');
                        tab.btn.classList.remove('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-500');
                        tab.btn.classList.add('text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-200', 'border-transparent');
                    }
                });

                 if (tabName === 'timeline') {
                    renderTimeline();
                }
            }


            async function loadRecipes() {
                if (!userId) return;
                try {
                    const recipesCol = collection(db, 'users', userId, 'recipes');
                    const q = query(recipesCol, orderBy("createdAt", "desc"));
                    const recipeSnapshot = await getDocs(q);
                    recipesCache = recipeSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    populateFilters();
                    filterRecipes(); 
                } catch (error) {
                    console.error("Error loading recipes:", error);
                    showNotification("Failed to load recipes.", 'error');
                }
            }

            async function loadAppliances() {
                if (!userId) return;
                try {
                    const appliancesCol = collection(db, 'users', userId, 'appliances');
                    const q = query(appliancesCol, orderBy("createdAt", "desc"));
                    const applianceSnapshot = await getDocs(q);
                    appliancesCache = applianceSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                } catch (error) {
                    console.error("Error loading appliances:", error);
                    showNotification("Failed to load appliances.", 'error');
                }
            }

            function renderRecipeCards(recipes) {
                recipeList.innerHTML = '';
                
                if (currentLayout === 'list') {
                    recipeList.className = 'flex flex-col gap-4';
                } else {
                    recipeList.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';
                }
                
                if (recipes.length === 0) {
                    recipeList.innerHTML = `<p class="text-center col-span-full text-gray-500">No recipes found. Try adjusting your filters!</p>`;
                    return;
                }
                recipes.forEach(recipe => {
                    const recipeCard = document.createElement('div');
                    const isSelected = selectedRecipeIds.has(recipe.id);
                    recipeCard.className = `bg-white dark:bg-gray-800 rounded-lg shadow cursor-pointer hover:shadow-xl transition-shadow relative recipe-card-selectable ${isSelected ? 'selected' : ''}`;
                    recipeCard.dataset.recipeId = recipe.id;
                    
                    if (currentLayout === 'list') {
                        recipeCard.innerHTML = `
                            <div class="flex items-center gap-4 p-4">
                                ${displayOptions.showImages ? `<img src="${recipe.imageUrl || 'https://placehold.co/150x150'}" alt="${recipe.name}" class="w-24 h-24 object-cover rounded-md flex-shrink-0">` : ''}
                                <div class="flex-grow">
                                    <h3 class="text-xl font-bold">${recipe.name}</h3>
                                    ${displayOptions.showDescription ? `<p class="text-sm text-gray-500 dark:text-gray-400 mt-1">${recipe.description || ''}</p>` : ''}
                                    ${displayOptions.showSource ? `<p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Source: ${recipe.sourceName || 'N/A'}</p>` : ''}
                                    ${displayOptions.showLabels && recipe.labels && recipe.labels.length > 0 ? `<div class="mt-2 flex flex-wrap gap-1">${recipe.labels.map(l => `<span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${l}</span>`).join('')}</div>` : ''}
                                </div>
                                 <button class="add-to-meal-plan-btn bg-green-500 text-white rounded-full w-8 h-8 flex items-center justify-center absolute top-2 right-2 hover:bg-green-600" title="Add to Meal Plan"><i class="fas fa-calendar-plus"></i></button>
                            </div>
                        `;
                    } else {
                        const totalTime = recipe.totalTime || 0;
                        recipeCard.innerHTML = `
                             <div class="relative">
                                ${displayOptions.showImages ? `<img src="${recipe.imageUrl || 'https://placehold.co/400x300'}" alt="${recipe.name}" class="w-full h-40 object-cover rounded-t-lg">` : ''}
                                <button class="add-to-meal-plan-btn bg-green-500 text-white rounded-full w-8 h-8 flex items-center justify-center absolute top-2 right-2 hover:bg-green-600" title="Add to Meal Plan"><i class="fas fa-calendar-plus"></i></button>
                            </div>
                            <div class="p-4">
                                <h3 class="text-xl font-bold">${recipe.name}</h3>
                                <p class="text-gray-600 dark:text-gray-400">${recipe.cuisine || 'Unspecified Cuisine'}</p>
                                <div class="mt-2 text-sm text-gray-500">
                                    <i class="fas fa-clock"></i>
                                    ${totalTime > 0 ? totalTime + ' mins' : 'N/A'}
                                </div>
                            </div>
                        `;
                    }

                    recipeCard.addEventListener('click', (e) => {
                        if (e.target.closest('.add-to-meal-plan-btn')) {
                            e.stopPropagation();
                            showNotification(`${recipe.name} added to meal plan (feature coming soon)!`, 'info');
                            return;
                        }

                        if (isMultiSelectMode || isShoppingListMode) {
                            if (selectedRecipeIds.has(recipe.id)) {
                                selectedRecipeIds.delete(recipe.id);
                            } else {
                                selectedRecipeIds.add(recipe.id);
                            }
                            recipeCard.classList.toggle('selected');
                            selectionCountEl.textContent = `${selectedRecipeIds.size} recipes selected`;
                        } else {
                            showRecipeDetailsModal(recipe.id);
                        }
                    });
                    recipeList.appendChild(recipeCard);
                });
            }
            
            function populateFilters() {
                const cuisines = new Set();
                const labels = new Set();
                recipesCache.forEach(recipe => {
                    if (recipe.cuisine) cuisines.add(recipe.cuisine);
                    if (recipe.labels) recipe.labels.forEach(label => labels.add(label));
                });

                filterCuisine.innerHTML = '<option value="">All Cuisines</option>';
                [...cuisines].sort().forEach(c => filterCuisine.innerHTML += `<option value="${c}">${c}</option>`);

                filterLabel.innerHTML = '<option value="">All Labels</option>';
                [...labels].sort().forEach(l => filterLabel.innerHTML += `<option value="${l}">${l}</option>`);
            }

            function filterRecipes() {
                const searchTerm = searchBar.value.toLowerCase();
                const selectedCuisine = filterCuisine.value;
                const selectedLabel = filterLabel.value;
                const minRating = Number(filterRating.value);

                let filtered = recipesCache.filter(recipe => {
                    const matchesSearch = searchTerm === '' || 
                        recipe.name.toLowerCase().includes(searchTerm) ||
                        (recipe.description && recipe.description.toLowerCase().includes(searchTerm)) ||
                        (recipe.cuisine && recipe.cuisine.toLowerCase().includes(searchTerm));
                    
                    const matchesCuisine = !selectedCuisine || recipe.cuisine === selectedCuisine;
                    const matchesLabel = !selectedLabel || (recipe.labels && recipe.labels.includes(selectedLabel));
                    const matchesRating = recipe.rating >= minRating;

                    return matchesSearch && matchesCuisine && matchesLabel && matchesRating;
                });
                const sorted = sortRecipes(filtered);
                renderRecipeCards(sorted);
            }
            
            function sortRecipes(recipes) {
                return [...recipes].sort((a, b) => {
                    switch(currentSort) {
                        case 'date-desc':
                            return (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0);
                        case 'date-asc':
                            return (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0);
                        case 'rating-desc':
                            return (b.rating || 0) - (a.rating || 0);
                        case 'title-asc':
                        default:
                            return a.name.localeCompare(b.name);
                    }
                });
            }

            function renderAddRatingStars(rating = 0) {
                const container = document.getElementById('add-recipe-rating');
                container.innerHTML = '';
                currentRating = rating;
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement('i');
                    star.className = 'fas fa-star cursor-pointer text-2xl';
                    star.dataset.value = i;
                    star.classList.toggle('text-yellow-400', i <= currentRating);
                    star.classList.toggle('text-gray-300', i > currentRating);
                    star.addEventListener('click', () => {
                        currentRating = i;
                        const stars = container.querySelectorAll('i');
                        stars.forEach(s => {
                            s.classList.toggle('text-yellow-400', s.dataset.value <= currentRating);
                            s.classList.toggle('text-gray-300', s.dataset.value > currentRating);
                        });
                    });
                    container.appendChild(star);
                }
            }
            
            const parseSections = (text) => {
                if (!text) return [];
                const lines = text.split('\n').filter(line => line.trim() !== '');
                const sections = [];
                let currentSection = { section: 'General', items: [] };

                for (const line of lines) {
                    const match = line.trim().match(/^\[(.*?)\]:?$/);
                    // A line is a heading if it consists only of the bracketed text (and optional colon)
                    if (match && match[0] === line.trim()) {
                        if (currentSection.items.length > 0) {
                            sections.push(currentSection);
                        }
                        currentSection = { section: match[1].trim(), items: [] };
                    } else {
                        const parts = line.split('##');
                        const itemText = parts[0].trim();
                        if (itemText) {
                            const item = { text: itemText };
                            if (parts.length > 1) {
                                item.tip = parts[1].trim();
                            }
                            currentSection.items.push(item);
                        }
                    }
                }
                if (currentSection.items.length > 0 || sections.length === 0) {
                    sections.push(currentSection);
                }
                return sections;
            };

            const formatSections = (sectionsArray) => {
                 if (!Array.isArray(sectionsArray)) return '';
                 return sectionsArray.map(sec => {
                     if (!sec || !Array.isArray(sec.items)) return ''; 
                     const header = sec.section && sec.section !== 'General' ? `[${sec.section}]\n` : '';
                     const items = sec.items.map(item => {
                         if (typeof item === 'string') return item;
                         if (typeof item === 'object' && item.text) return item.text + (item.tip ? ` ## ${item.tip}` : '');
                         return '';
                     }).join('\n');
                     return header + items;
                 }).join('\n\n');
            }

async function handleAddOrUpdateRecipe() {
    if (!userId) {
        return showNotification("Please log in to add recipes.", "error");
    }

    const name = document.getElementById('recipe-name').value;
    if (!name) {
        return showNotification("Please fill out the Title.", "error");
    }
    
    addRecipeBtn.disabled = true;
    addRecipeBtn.textContent = "Saving...";

    try {
        let imageUrl = editingRecipeId ? (recipesCache.find(r => r.id === editingRecipeId)?.imageUrl || '') : '';
        const imageFile = document.getElementById('recipe-image-upload').files[0];

        if (imageFile) {
            const imageRef = ref(storage, `users/${userId}/recipes/${Date.now()}_${imageFile.name}`);
            await uploadBytes(imageRef, imageFile);
            imageUrl = await getDownloadURL(imageRef);
        } else if (importedImageUrl) {
            imageUrl = importedImageUrl;
        }

        const linkedRecipesSelect = document.getElementById('linked-recipes-select');
        const linkedRecipeIds = [...linkedRecipesSelect.selectedOptions].map(option => option.value);

        const flavorProfile = [];
        if (document.getElementById('flavor-sweet').checked) flavorProfile.push('Sweet');
        if (document.getElementById('flavor-savoury').checked) flavorProfile.push('Savoury');
        
        // --- Process Instructions and Step Images ---
        let rawInstructions = getInstructionsFromBuilder();
        
        // Recursively upload images for steps
        for (const section of rawInstructions) {
            if (section.items) {
                for (const item of section.items) {
                    if (item.imageFile) {
                        const stepImgRef = ref(storage, `users/${userId}/recipes/steps/${Date.now()}_${item.imageFile.name}`);
                        await uploadBytes(stepImgRef, item.imageFile);
                        item.imageUrl = await getDownloadURL(stepImgRef);
                        delete item.imageFile; // Don't save the file object to Firestore
                    }
                }
            }
        }

        const isFoodItem = document.getElementById('is-food-item-toggle')?.checked || false;

        const recipeData = {
            name,
            description: document.getElementById('recipe-description').value,
            cuisine: document.getElementById('recipe-cuisine').value,
            sourceName: document.getElementById('recipe-source-name').value,
            sourceUrl: document.getElementById('recipe-source-url').value,
            yield: {
                quantity: Number(document.getElementById('recipe-yield-quantity').value) || null,
                unit: document.getElementById('recipe-yield-unit').value
            },
            prepTime: Number(document.getElementById('recipe-prep-time').value) || 0,
            cookTime: Number(document.getElementById('recipe-cook-time').value) || 0,
            restingTime: Number(document.getElementById('recipe-resting-time').value) || 0,
            totalTime: Number(document.getElementById('recipe-total-time').value) || 0,
            discoveredDate: document.getElementById('recipe-discovered-date').value,
            mealType: document.getElementById('recipe-meal-type').value,
            category: document.getElementById('recipe-category').value,
            flavorProfile: flavorProfile,
            ingredients: parseSections(document.getElementById('recipe-ingredients').value),
            instructions: rawInstructions,
            notes: document.getElementById('recipe-notes').value,
            labels: document.getElementById('recipe-labels').value.split(',').map(l => l.trim()).filter(Boolean),
            rating: currentRating,
            imageUrl,
            linkedRecipeIds,
            isFoodItem, // Save the Food Mode flag
            updatedAt: serverTimestamp(),
            updatedBy: userId,
            approvals: editingRecipeId ? (recipesCache.find(r => r.id === editingRecipeId)?.approvals || []) : []
        };

        if (!editingRecipeId) {
            const discoveredDate = document.getElementById('recipe-discovered-date').value;
            recipeData.createdAt = discoveredDate ? new Date(discoveredDate) : serverTimestamp();
            recipeData.ingredientNotes = {};
            recipeData.instructionNotes = {};
            recipeData.createdBy = userId;
            if (importedImageUrl) {
                recipeData.importedFromUrl = document.getElementById('import-url-input').value;
                recipeData.importedAt = serverTimestamp();
                if (!recipeData.labels.includes('imported')) {
                    recipeData.labels.push('imported');
                }
            }
        }

        if (editingRecipeId) {
            const recipeRef = doc(db, 'users', userId, 'recipes', editingRecipeId);
            await updateDoc(recipeRef, recipeData);
            showNotification("Recipe updated successfully!");
        } else {
            const recipesCol = collection(db, 'users', userId, 'recipes');
            await addDoc(recipesCol, recipeData);
            showNotification("Recipe added successfully!");
        }
        
        await loadRecipes();

        if (!editingRecipeId && fetchedRecipesCache.length > 0) {
            fetchedRecipesCache.shift();
            if (fetchedRecipesCache.length > 0) {
                showNextImportModal();
            } else {
                resetForm();
            }
        } else {
            resetForm();
        }

    } catch (error) {
        console.error("Error saving recipe:", error);
        showNotification("Failed to save recipe.", "error");
    } finally {
        addRecipeBtn.disabled = false;
        addRecipeBtn.textContent = editingRecipeId ? "Save Changes" : "Add Recipe";
    }
}

            function resetForm() {
                switchTab('recipes');
                form.reset();
                document.getElementById('recipe-discovered-date').valueAsDate = new Date();
                currentRating = 0;
                renderAddRatingStars();
                
                // FIX: Clear the dynamic instruction builder
                renderInstructionBuilder([]); 

                editingRecipeId = null;
                importedImageUrl = null;
                fetchedRecipesCache = [];
                importReviewSection.classList.add('hidden');
                document.getElementById('import-url-input').value = '';
                document.getElementById('import-txt-url-input').value = '';
                formSummary.textContent = "Add a New Recipe";
                addRecipeBtn.textContent = "Add Recipe";
                document.getElementById('form-buttons').querySelector('#cancel-edit-btn')?.remove();
                document.getElementById('image-preview').classList.add('hidden');
                populateLinkedRecipesSelect();
            }
            function populateFormForEdit(recipeOrId) {
                const isEditing = typeof recipeOrId === 'string';
                const recipe = isEditing
                    ? recipesCache.find(r => r.id === recipeOrId)
                    : recipeOrId;
                
                if (!recipe) return;

                editingRecipeId = isEditing ? recipeOrId : null;

                const ingredientsForForm = processData(recipe.ingredients, 'Ingredients');
                const instructionsForForm = processData(recipe.instructions, 'Instructions');

                const flavors = recipe.flavorProfile || [];
document.getElementById('flavor-sweet').checked = flavors.includes('Sweet');
document.getElementById('flavor-savoury').checked = flavors.includes('Savoury');

                document.getElementById('recipe-name').value = recipe.name || '';
                document.getElementById('recipe-description').value = recipe.description || '';
                document.getElementById('recipe-cuisine').value = recipe.cuisine || '';
                document.getElementById('recipe-source-name').value = recipe.sourceName || '';
                document.getElementById('recipe-source-url').value = recipe.sourceUrl || '';
                if (typeof recipe.yield === 'object' && recipe.yield !== null) {
                    document.getElementById('recipe-yield-quantity').value = recipe.yield.quantity || '';
                    document.getElementById('recipe-yield-unit').value = recipe.yield.unit || 'servings';
                } else {
                    document.getElementById('recipe-yield-quantity').value = recipe.yield || ''; 
                    document.getElementById('recipe-yield-unit').value = 'servings';
                }
                document.getElementById('recipe-prep-time').value = recipe.prepTime || '';
                document.getElementById('recipe-cook-time').value = recipe.cookTime || '';
                document.getElementById('recipe-resting-time').value = recipe.restingTime || '';
                document.getElementById('recipe-total-time').value = recipe.totalTime || '';
                document.getElementById('recipe-discovered-date').value = recipe.discoveredDate || '';
                document.getElementById('recipe-meal-type').value = recipe.mealType || '';
                document.getElementById('recipe-category').value = recipe.category || '';
                document.getElementById('recipe-notes').value = recipe.notes || '';
                document.getElementById('recipe-labels').value = (recipe.labels || []).join(', ');
                document.getElementById('recipe-ingredients').value = formatSections(ingredientsForForm);
                // Use the raw object data, not the formatted text string
    renderInstructionBuilder(recipe.instructions || []);
                renderAddRatingStars(recipe.rating || 0);
                populateLinkedRecipesSelect(recipe.linkedRecipeIds);
                
                if (isEditing) {
                    formSummary.textContent = `Editing: ${recipe.name}`;
                    addRecipeBtn.textContent = "Save Changes";
                } else {
                    formSummary.textContent = `Adding New Recipe (from copy): ${recipe.name}`;
                    addRecipeBtn.textContent = "Add Recipe";
                }
                
                switchTab('add-recipe');
                window.scrollTo({ top: 0, behavior: 'smooth' });

                if (!document.getElementById('cancel-edit-btn')) {
                    const cancelBtn = document.createElement('button');
                    cancelBtn.id = 'cancel-edit-btn';
                    cancelBtn.type = 'button';
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.className = 'bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600';
                    cancelBtn.addEventListener('click', resetForm);
                    document.getElementById('form-buttons').appendChild(cancelBtn);
                }
            }

            function printRecipe(recipe) {
                const printArea = document.getElementById('print-area');
                
                // Process data for display
                const ingredientsData = processData(recipe.ingredients, 'Ingredients');
                const instructionsData = processData(recipe.instructions, 'Instructions');

                // Format Ingredients for Print (with checkboxes)
                const ingredientsHtml = ingredientsData.map(section => `
                    <h3 class="font-bold mt-4 uppercase text-sm border-b border-gray-300 mb-2">${section.section}</h3>
                    <ul class="space-y-1 text-sm">
                        ${(section.items || []).map(item => {
                            const text = typeof item === 'string' ? item : item.text;
                            const tip = (typeof item === 'object' && item.tip) ? ` <i class="text-xs">(${item.tip})</i>` : '';
                            return `<li class="flex items-start gap-2">
                                <span class="inline-block w-4 h-4 border border-gray-400 rounded-sm mt-0.5 flex-shrink-0"></span>
                                <span>${text}${tip}</span>
                            </li>`;
                        }).join('')}
                    </ul>
                `).join('');

                // Format Instructions for Print
                const instructionsHtml = instructionsData.map(section => `
                    <h3 class="font-bold mt-4 uppercase text-sm border-b border-gray-300 mb-2">${section.section}</h3>
                    <ol class="list-decimal list-inside space-y-2 text-sm">
                        ${(section.items || []).map(item => {
                            const text = typeof item === 'string' ? item : item.text;
                            const tip = (typeof item === 'object' && item.tip) ? ` <i class="text-xs">(${item.tip})</i>` : '';
                            return `<li class="mb-2 pl-2 border-l-2 border-gray-100">${text}${tip}</li>`;
                        }).join('')}
                    </ol>
                `).join('');

                // Generate Layout
                const yieldText = typeof recipe.yield === 'object' && recipe.yield !== null 
                    ? `${recipe.yield.quantity || ''} ${recipe.yield.unit || ''}` 
                    : recipe.yield || 'N/A';

                printArea.innerHTML = `
                    <div class="max-w-4xl mx-auto">
                        <div class="flex items-start justify-between mb-6 border-b-2 border-black pb-4">
                            <div>
                                <h1 class="text-3xl font-bold mb-2">${recipe.name}</h1>
                                <div class="text-sm space-y-1 text-gray-600">
                                    <p><strong>Source:</strong> ${recipe.sourceName || 'N/A'}</p>
                                    <p><strong>Cuisine:</strong> ${recipe.cuisine || 'N/A'}</p>
                                </div>
                            </div>
                            ${recipe.imageUrl ? `<img src="${recipe.imageUrl}" class="w-32 h-32 object-cover rounded-lg border border-gray-300">` : ''}
                        </div>

                        <div class="grid grid-cols-4 gap-4 mb-6 text-sm bg-gray-50 p-4 rounded border border-gray-200">
                            <div><span class="font-bold block text-gray-500 text-xs uppercase">Prep Time</span>${recipe.prepTime || '-'} mins</div>
                            <div><span class="font-bold block text-gray-500 text-xs uppercase">Cook Time</span>${recipe.cookTime || '-'} mins</div>
                            <div><span class="font-bold block text-gray-500 text-xs uppercase">Total Time</span>${recipe.totalTime || '-'} mins</div>
                            <div><span class="font-bold block text-gray-500 text-xs uppercase">Yield</span>${yieldText}</div>
                        </div>

                        <div class="print-grid">
                            <div>
                                <h2 class="text-xl font-bold mb-2">Ingredients</h2>
                                ${ingredientsHtml}
                                
                                ${recipe.notes ? `
                                    <div class="mt-8 pt-4 border-t border-gray-300">
                                        <h3 class="font-bold text-sm uppercase mb-2">Notes</h3>
                                        <p class="text-sm italic text-gray-600">${recipe.notes}</p>
                                    </div>
                                ` : ''}
                            </div>
                            <div>
                                <h2 class="text-xl font-bold mb-2">Instructions</h2>
                                ${instructionsHtml}
                            </div>
                        </div>
                        
                        <div class="mt-12 pt-4 border-t border-gray-300 text-center text-xs text-gray-400">
                            Printed via SH's RecipeManagr on ${new Date().toLocaleString()}
                        </div>
                    </div>
                `;

                // Trigger Browser Print
                window.print();
            }

            // --- Timer Helper Functions (MOVED HERE) ---

            const parseDurationToMillis = (val, unit) => {
                let multiplier = 1000; // seconds
                if (unit.startsWith('m')) multiplier *= 60;
                else if (unit.startsWith('h')) multiplier *= 3600;
                return val * multiplier;
            };

            // Converts text like "(10 mins)" into clickable timer HTML
            const renderTextWithTimers = (text) => {
                // Regex matches: ( number space unit ) e.g. (5 mins), (1.5 h), (30s)
                const regex = /\((\d+(?:\.\d+)?)\s*(m|min|mins|minutes?|h|hr|hrs|hours?|s|sec|secs?|seconds?)\)/gi;
                
                return text.replace(regex, (match, val, unit) => {
                    const millis = parseDurationToMillis(parseFloat(val), unit.toLowerCase());
                    const displayUnit = unit.toLowerCase().startsWith('h') ? 'h' : (unit.toLowerCase().startsWith('m') ? 'm' : 's');
                    return `<button class="timer-btn" data-original-text="${val}${displayUnit}" data-millis="${millis}"><i class="fas fa-stopwatch"></i> ${val}${displayUnit}</button>`;
                });
            };

            // --- Instruction Builder Helpers ---

const createInstructionRow = (data = {}) => {
    const row = document.createElement('div');
    row.className = 'instruction-row flex flex-col md:flex-row gap-2 items-start bg-gray-50 dark:bg-gray-700/50 p-2 rounded border border-gray-200 dark:border-gray-600';
    row.dataset.type = 'step';

    const text = data.text || '';
    const timeVal = data.timer ? data.timer.val : '';
    const timeUnit = data.timer ? data.timer.unit : 'm';
    const imageUrl = data.imageUrl || '';

    row.innerHTML = `
        <div class="flex-grow w-full space-y-2">
            <textarea placeholder="Step instruction..." rows="2" class="step-text w-full p-2 text-sm border rounded dark:bg-gray-700 dark:border-gray-600 resize-y">${text}</textarea>
            ${imageUrl ? `<div class="step-image-preview relative w-fit"><img src="${imageUrl}" class="h-20 rounded border"><button type="button" class="remove-img-btn absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs"><i class="fas fa-times"></i></button></div>` : ''}
        </div>
        <div class="flex flex-col gap-2 flex-shrink-0">
            <div class="flex items-center border rounded dark:border-gray-600 bg-white dark:bg-gray-700 overflow-hidden">
                <div class="px-2 text-gray-400 text-xs"><i class="fas fa-stopwatch"></i></div>
                <input type="number" placeholder="0" value="${timeVal}" class="step-time w-12 p-1 text-sm text-center outline-none dark:bg-gray-700 border-r dark:border-gray-600 appearance-none">
                <select class="step-unit p-1 text-sm bg-gray-50 dark:bg-gray-700 outline-none cursor-pointer">
                    <option value="s" ${timeUnit === 's' ? 'selected' : ''}>s</option>
                    <option value="m" ${timeUnit === 'm' ? 'selected' : ''}>m</option>
                    <option value="h" ${timeUnit === 'h' ? 'selected' : ''}>h</option>
                </select>
            </div>
            <label class="cursor-pointer bg-indigo-50 dark:bg-indigo-900/50 hover:bg-indigo-100 text-indigo-600 dark:text-indigo-300 border border-indigo-200 dark:border-indigo-700 p-1 rounded text-xs text-center flex items-center justify-center gap-1 transition-colors">
                <i class="fas fa-camera"></i> <span>Add Img</span>
                <input type="file" class="step-image-input hidden" accept="image/*">
            </label>
            <button type="button" class="remove-row-btn text-red-400 hover:text-red-600 p-1 text-center"><i class="fas fa-trash-alt"></i></button>
        </div>
    `;

    // Handle image file selection preview
    const fileInput = row.querySelector('.step-image-input');
    fileInput.addEventListener('change', (e) => {
        if (fileInput.files && fileInput.files[0]) {
             const lbl = row.querySelector('label span');
             lbl.textContent = 'Selected';
             lbl.parentElement.classList.add('bg-green-50', 'text-green-600', 'border-green-200');
        }
    });

    // Handle removing existing image
    const removeImgBtn = row.querySelector('.remove-img-btn');
    if (removeImgBtn) {
        removeImgBtn.addEventListener('click', () => {
            row.dataset.removeImage = 'true';
            row.querySelector('.step-image-preview').remove();
        });
    }

    row.querySelector('.remove-row-btn').addEventListener('click', () => row.remove());
    return row;
};



const createSectionRow = (title = '') => {
    const row = document.createElement('div');
    row.className = 'instruction-row flex gap-2 items-center mt-4 mb-1';
    row.dataset.type = 'section';

    row.innerHTML = `
        <div class="flex-grow bg-gray-200 dark:bg-gray-600 h-px"></div>
        <input type="text" placeholder="Section Name (e.g. Sauce)" value="${title}" class="section-title font-bold text-sm text-center bg-transparent border-b border-gray-300 dark:border-gray-500 focus:border-indigo-500 outline-none w-1/2">
        <div class="flex-grow bg-gray-200 dark:bg-gray-600 h-px"></div>
        <button type="button" class="remove-row-btn text-gray-400 hover:text-red-500"><i class="fas fa-times"></i></button>
    `;

    row.querySelector('.remove-row-btn').addEventListener('click', () => row.remove());
    return row;
};

const renderInstructionBuilder = (sections) => {
    const container = document.getElementById('instructions-builder');
    container.innerHTML = '';

    if (!sections || sections.length === 0) {
        // Add one empty step by default
        container.appendChild(createInstructionRow());
        return;
    }

    sections.forEach(section => {
        // Only render section header if it's not the default "Instructions" or "General"
        if (section.section && section.section !== 'Instructions' && section.section !== 'General') {
            container.appendChild(createSectionRow(section.section));
        }
        
        if (section.items) {
            section.items.forEach(item => {
                // Handle legacy string items vs object items
                const data = typeof item === 'string' ? { text: item } : item;
                container.appendChild(createInstructionRow(data));
            });
        }
    });
};

const getInstructionsFromBuilder = () => {
    const container = document.getElementById('instructions-builder');
    const rows = container.querySelectorAll('.instruction-row');
    
    const sections = [];
    let currentSection = { section: 'Instructions', items: [] };

    rows.forEach(row => {
        if (row.dataset.type === 'section') {
            if (currentSection.items.length > 0) sections.push(currentSection);
            const title = row.querySelector('.section-title').value.trim() || 'Section';
            currentSection = { section: title, items: [] };
        } else {
            const text = row.querySelector('.step-text').value.trim();
            // We include items even if text is empty if they have an image
            const fileInput = row.querySelector('.step-image-input');
            const hasFile = fileInput && fileInput.files.length > 0;
            const existingImg = row.querySelector('.step-image-preview');

            if (text || hasFile || existingImg) {
                const item = { text };
                const timeVal = row.querySelector('.step-time').value;
                const timeUnit = row.querySelector('.step-unit').value;
                
                if (timeVal) {
                    item.timer = { val: parseFloat(timeVal), unit: timeUnit };
                }
                
                // Attach file object to item for processing in handleAddOrUpdateRecipe
                if (hasFile) {
                    item.imageFile = fileInput.files[0];
                }
                
                // Persist existing URL unless removed
                if (existingImg && !row.dataset.removeImage) {
                    const imgTag = existingImg.querySelector('img');
                    if (imgTag) item.imageUrl = imgTag.src;
                }

                currentSection.items.push(item);
            }
        }
    });

    if (currentSection.items.length > 0 || sections.length === 0) {
        sections.push(currentSection);
    }
    
    return sections;
};

            const playTimerSound = () => {
                // Simple beep using AudioContext
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return;
                    const ctx = new AudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.5);
                } catch(e) { console.error("Audio play failed", e); }
            };

            async function showRecipeDetailsModal(recipeId) {
                // ... (rest of the function remains the same)
    let recipe = recipesCache.find(r => r.id === recipeId);
    if (!recipe) return;
    
    // Ensure data structures exist
    recipe.ingredientNotes = recipe.ingredientNotes || {};
    recipe.instructionNotes = recipe.instructionNotes || {};
    recipe.approvals = recipe.approvals || [];

    // Helper to keep screen awake
    let wakeLock = null;
    const toggleWakeLock = async (btn) => {
        if ('wakeLock' in navigator) {
            try {
                if (wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                    btn.classList.remove('text-yellow-500', 'bg-yellow-100');
                    btn.classList.add('text-gray-400');
                    showNotification("Screen will sleep normally.");
                } else {
                    wakeLock = await navigator.wakeLock.request('screen');
                    btn.classList.remove('text-gray-400');
                    btn.classList.add('text-yellow-500', 'bg-yellow-100');
                    showNotification("Screen set to stay awake!");
                }
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
                showNotification("Wake Lock not supported by this browser.", "error");
            }
        }
    };

    // Helper for Native Sharing
    const shareRecipe = async () => {
        const shareData = {
            title: recipe.name,
            text: `Check out this recipe for ${recipe.name}!`,
            url: window.location.href // Or a specific recipe deep link if you have routing
        };
        if (navigator.share) {
            try { await navigator.share(shareData); } catch (err) { console.log('Share canceled'); }
        } else {
            // Fallback: Copy to clipboard
            navigator.clipboard.writeText(`${recipe.name}\n\n${recipe.description || ''}`);
            showNotification("Recipe info copied to clipboard.");
        }
    };

    // Process Content
    const ingredientsData = processData(recipe.ingredients, 'Ingredients');
    const instructionsData = processData(recipe.instructions, 'Instructions');

    // Calculate Active Time from Steps
let totalActiveMillis = 0;
instructionsData.forEach(section => {
    (section.items || []).forEach(item => {
        if(item && item.timer) {
            totalActiveMillis += parseDurationToMillis(item.timer.val, item.timer.unit);
        }
    });
});
const activeTimeMins = Math.round(totalActiveMillis / 60000);

    // Fetch History for "Last Cooked" block
    let lastCookedHtml = '';
    try {
        const historyCol = collection(db, 'users', userId, 'recipes', recipeId, 'history');
        const q = query(historyCol, orderBy('cookedAt', 'desc'), limit(1));
        const historySnapshot = await getDocs(q);
        if (!historySnapshot.empty) {
            const lastLog = historySnapshot.docs[0].data();
            const lastCookedDate = lastLog.cookedAt ? new Date(lastLog.cookedAt).toLocaleDateString() : 'N/A';
            const lastCookedRatingHtml = Array.from({length: 5}, (_, i) => 
                `<i class="fas fa-star ${i < lastLog.rating ? 'text-yellow-400' : 'text-gray-300'}"></i>`
            ).join('');

            lastCookedHtml = `
            <div class="mt-4 p-3 bg-indigo-50 dark:bg-indigo-900/50 rounded-lg border border-indigo-200 dark:border-indigo-800 text-sm">
                <h5 class="font-bold text-indigo-800 dark:text-indigo-200 flex items-center"><i class="fas fa-history mr-2"></i>Last Cooked (${lastCookedDate})</h5>
                <div class="flex items-center my-1 text-xs">${lastCookedRatingHtml}</div>
                <p class="text-gray-600 dark:text-gray-400 italic">"${lastLog.notes || 'No notes were left.'}"</p>
            </div>`;
        }
    } catch(e) { console.error("Could not fetch last cooked history", e); }
    
    // HTML Generators (Ingredients & Instructions)
    const ingredientsHtml = ingredientsData.map(section => `
        <h5 class="font-bold mt-3 text-gray-500 dark:text-gray-400 uppercase text-xs tracking-wider">${section.section}</h5>
        <ul class="list-none space-y-2 mt-1 pl-1">
            ${(section.items || []).map(item => {
                const itemText = item ? item.text : '';
                const itemTip = item ? item.tip : '';
                return `<li data-type="ingredient" data-key="${itemText}" class="relative pl-4 before:content-['â€¢'] before:absolute before:left-0 before:text-indigo-400 group">
                <span class="cursor-pointer hover:text-gray-500 transition-colors">${itemText} ${itemTip ? `<span class="text-xs text-gray-400 italic">(${itemTip})</span>` : ''}</span>
                <button class="add-note-btn opacity-0 group-hover:opacity-100 transition-opacity text-indigo-500 hover:text-indigo-700 ml-2"><i class="fas fa-plus-circle"></i></button>
                ${renderNote(recipe.ingredientNotes[createSafeKey(itemText)])}
            </li>`}).join('')}
        </ul>
    `).join('');

    const instructionsHtml = instructionsData.map(section => `
    <h5 class="font-bold mt-3 text-gray-500 dark:text-gray-400 uppercase text-xs tracking-wider">${section.section}</h5>
    <ol class="list-decimal list-inside space-y-3 mt-1">
            ${(section.items || []).map(item => {
                const itemText = typeof item === 'object' ? item.text : item;
                const itemTip = (typeof item === 'object' && item.tip) ? item.tip : '';
                const itemImg = (typeof item === 'object' && item.imageUrl) ? item.imageUrl : '';

                let contentHtml = renderTextWithTimers(itemText);

                if (typeof item === 'object' && item.timer) {
                    const millis = parseDurationToMillis(item.timer.val, item.timer.unit);
                    const display = `${item.timer.val}${item.timer.unit}`;
                    contentHtml += ` <button class="timer-btn ml-2" data-original-text="${display}" data-millis="${millis}"><i class="fas fa-stopwatch"></i> ${display}</button>`;
                }

                return `<li data-type="instruction" data-key="${itemText}" class="group pl-1">
            <div class="inline-block">
                <span class="cursor-pointer hover:text-gray-500 transition-colors">${contentHtml} ${itemTip ? `<span class="text-xs text-gray-400 italic">(${itemTip})</span>` : ''}</span>
                <button class="add-note-btn opacity-0 group-hover:opacity-100 transition-opacity text-indigo-500 hover:text-indigo-700 ml-2"><i class="fas fa-plus-circle"></i></button>
                ${itemImg ? `<div class="mt-2"><img src="${itemImg}" class="max-h-48 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700"></div>` : ''}
                ${renderNote(recipe.instructionNotes[createSafeKey(itemText)])}
            </div>
        </li>`}).join('')}
    </ol>
`).join('');
    
    const yieldText = typeof recipe.yield === 'object' && recipe.yield !== null ? `${recipe.yield.quantity || ''} ${recipe.yield.unit || ''}` : recipe.yield || 'N/A';

    // --- MAIN MODAL TEMPLATE ---
    modalContainer.innerHTML = `
<div class="bg-gray-100 dark:bg-gray-900 rounded-none md:rounded-lg shadow-2xl w-full h-full md:h-auto md:max-h-[90vh] md:max-w-6xl flex flex-col">
    <div class="p-3 bg-white dark:bg-gray-800 md:rounded-t-lg shadow-sm z-10 flex-shrink-0 border-b dark:border-gray-700">
        <div class="flex items-center gap-3">
            <img src="${recipe.imageUrl || 'https://placehold.co/150x150/e2e8f0/adb5bd?text=No+Image'}" alt="${recipe.name}" class="w-12 h-12 md:w-20 md:h-20 object-cover rounded-md flex-shrink-0 border border-gray-200 dark:border-gray-600">
            <div class="flex-grow min-w-0">
                <h2 class="text-lg md:text-3xl font-bold truncate leading-tight">${recipe.name}</h2>
                <div class="flex items-center flex-wrap gap-x-3 gap-y-1 mt-1">
                    <div class="modal-rating-stars flex items-center gap-1 text-sm"></div>
                    <button id="wakelock-btn" class="text-gray-400 hover:text-yellow-500 p-1 rounded-full transition-colors" title="Keep Screen On">
                        <i class="fas fa-lightbulb"></i> <span class="text-xs hidden md:inline">Screen Awake</span>
                    </button>
                </div>
            </div>
            <button class="modal-close-btn p-2 -mr-2 text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-full flex-shrink-0"><i class="fas fa-times text-xl"></i></button>
        </div>
    </div>

    <div class="p-4 md:p-6 overflow-y-auto flex-grow" id="modal-content-area">
        ${recipe.description ? `<p class="mb-4 text-sm md:text-base text-gray-600 dark:text-gray-300 bg-white dark:bg-gray-800 p-3 rounded-lg border dark:border-gray-700 italic">${recipe.description}</p>` : ''}
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            
            <div class="md:col-span-2 order-1 md:order-2">
                
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border dark:border-gray-700 mb-6">
                    <div class="flex justify-between items-end mb-2 border-b dark:border-gray-700 pb-2">
                        <h4 class="text-lg md:text-xl font-bold"><i class="fas fa-carrot text-orange-500 mr-2"></i>Ingredients</h4>
                        
                        <div class="flex items-center gap-2 text-xs">
                                <select id="scale-select" class="bg-gray-50 dark:bg-gray-700 border dark:border-gray-600 rounded px-1 py-1">
                                <option value="0.5">0.5x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                                <option value="3">3x</option>
                                <option value="4">4x</option>
                            </select>
                            <select id="unit-system-select" class="bg-gray-50 dark:bg-gray-700 border dark:border-gray-600 rounded px-1 py-1 max-w-[80px]">
                                <option value="original">Orig</option>
                                <option value="us_customary">US</option>
                                <option value="uk_metric">Metric</option>
                                <option value="au_metric">AU Met</option>
                            </select>
                        </div>
                    </div>
                    <div id="modal-ingredients" class="text-sm md:text-base leading-relaxed">${ingredientsHtml}</div>
                </div>

                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border dark:border-gray-700">
                        <h4 class="text-lg md:text-xl font-bold mb-2 border-b dark:border-gray-700 pb-2"><i class="fas fa-list-ol text-indigo-500 mr-2"></i>Instructions</h4>
                        ${lastCookedHtml}
                        <div id="modal-instructions" class="text-sm md:text-base leading-relaxed">${instructionsHtml}</div>
                </div>
            </div>

            <div class="md:col-span-1 order-2 md:order-1">
                    <details class="group bg-white dark:bg-gray-800 rounded-lg shadow-sm border dark:border-gray-700 overflow-hidden" ${window.innerWidth > 768 ? 'open' : ''}>
                    <summary class="md:hidden flex justify-between items-center p-3 font-bold cursor-pointer bg-gray-50 dark:bg-gray-700 select-none">
                        <span><i class="fas fa-info-circle mr-2 text-indigo-500"></i>Recipe Details</span>
                        <span class="transition-transform group-open:rotate-180"><i class="fas fa-chevron-down"></i></span>
                    </summary>
                    
                    <div class="p-4 space-y-4 text-sm">
                        <div>
                                <h4 class="text-lg font-bold mb-2 border-b dark:border-gray-700 pb-1 hidden md:block">Details</h4>
                                <div class="space-y-2 text-gray-700 dark:text-gray-300">
                                <p class="flex justify-between"><strong>Yield:</strong> <span>${yieldText}</span></p>
                                <p class="flex justify-between"><strong>Prep Time:</strong> <span>${recipe.prepTime || 'N/A'} min</span></p>
                                <p class="flex justify-between"><strong>Cook Time:</strong> <span>${recipe.cookTime || 'N/A'} min</span></p>
                                ${activeTimeMins > 0 ? `<p class="flex justify-between text-indigo-600 dark:text-indigo-400"><strong>Active Step Time:</strong> <span>${activeTimeMins} min</span></p>` : ''}
                                <p class="flex justify-between"><strong>Resting Time:</strong> <span>${recipe.restingTime || '0'} min</span></p>
                                <p class="flex justify-between"><strong>Total Time:</strong> <span>${recipe.totalTime || 'N/A'} min</span></p>
                                <p class="flex justify-between"><strong>Flavor:</strong> <span>${(recipe.flavorProfile || []).join(', ') || '-'}</span></p>
                                <p class="flex justify-between"><strong>Meal Type:</strong> <span>${recipe.mealType || '-'}</span></p>
                                <p class="flex justify-between"><strong>Category:</strong> <span>${recipe.category || '-'}</span></p>
                                
                                <p class="flex justify-between"><strong>Discovered:</strong> <span>${recipe.discoveredDate || '-'}</span></p>
                                ${recipe.sourceName ? `
    <p class="flex justify-between">
        <strong>Source:</strong> 
        <span>
            ${recipe.sourceUrl ? `<a href="${recipe.sourceUrl}" target="_blank" class="text-indigo-500 hover:underline">${recipe.sourceName} <i class="fas fa-external-link-alt text-xs"></i></a>` : recipe.sourceName}
        </span>
    </p>
` : ''}
                            </div>
                            <div class="mt-4">
                                <strong class="block mb-1 text-xs uppercase text-gray-500">Labels</strong>
                                <div id="modal-labels-container" class="flex flex-wrap gap-1"></div>
                            </div>
                        </div>

                        <div id="linked-recipes-section" class="pt-4 border-t dark:border-gray-700">
                                <h4 class="font-bold mb-2">Related Recipes</h4>
                                <div id="linked-recipes-list" class="space-y-1"></div>
                            </div>

                        <div id="approvals-section" class="pt-4 border-t dark:border-gray-700">
                                <h4 class="font-bold mb-2">Approved By</h4>
                                <div id="approvals-list" class="flex flex-wrap gap-2 mb-2"></div>
                                <div class="flex gap-2">
                                    <input type="text" id="approval-name-input" placeholder="Name" class="p-1.5 border rounded dark:bg-gray-700 dark:border-gray-600 text-sm flex-grow min-w-0">
                                    <button id="add-approval-btn" class="bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300 font-bold px-3 rounded text-sm hover:bg-green-200"><i class="fas fa-plus"></i></button>
                                </div>
                            </div>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <div class="p-3 bg-white dark:bg-gray-800 border-t dark:border-gray-700 flex flex-col md:flex-row gap-3 md:items-center justify-between rounded-b-none md:rounded-b-lg safe-area-pb flex-shrink-0">
            <div class="text-xs text-gray-400 order-2 md:order-1 text-center md:text-left hidden md:block">
            <span>Updated: ${recipe.updatedAt ? recipe.updatedAt.toDate().toLocaleDateString() : 'N/A'}</span>
        </div>
            <div class="flex flex-nowrap gap-2 overflow-x-auto pb-1 md:pb-0 justify-start md:justify-end order-1 md:order-2 w-full md:w-auto px-1 md:px-0">
                <button id="modal-log-btn" class="flex-shrink-0 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm"><i class="fas fa-check-circle mr-1"></i> Log Cook</button>
                <button id="modal-edit-btn" class="flex-shrink-0 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg text-sm"><i class="fas fa-edit mr-1"></i> Edit</button>
                <button id="modal-share-btn" class="flex-shrink-0 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/40 dark:hover:bg-blue-800 text-blue-700 dark:text-blue-300 font-bold py-2 px-3 rounded-lg text-sm"><i class="fas fa-share-alt"></i></button>
                <button id="modal-view-history-btn" class="flex-shrink-0 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900/40 dark:hover:bg-purple-800 text-purple-700 dark:text-purple-300 font-bold py-2 px-3 rounded-lg text-sm"><i class="fas fa-history"></i></button>
                <button id="modal-print-btn" class="flex-shrink-0 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-3 rounded-lg text-sm"><i class="fas fa-print"></i></button>
                <button id="modal-duplicate-btn" class="flex-shrink-0 bg-yellow-100 hover:bg-yellow-200 dark:bg-yellow-900/40 dark:hover:bg-yellow-800 text-yellow-700 dark:text-yellow-300 font-bold py-2 px-3 rounded-lg text-sm"><i class="fas fa-copy"></i></button>
                <button id="modal-delete-btn" class="flex-shrink-0 bg-red-100 hover:bg-red-200 dark:bg-red-900/40 dark:hover:bg-red-800 text-red-600 dark:text-red-300 font-bold py-2 px-3 rounded-lg text-sm"><i class="fas fa-trash"></i></button>
                <button class="modal-close-btn flex-shrink-0 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded-lg text-sm">Close</button>
        </div>
    </div>
</div>`;
    
    // --- Initial Render Logic ---
    renderReadOnlyRating(recipe.rating || 0);
    renderModalLabels(recipe);
    renderApprovals(recipe.id, recipe.approvals);
    renderLinkedRecipes(recipe.id);

    // --- Event Listeners ---
    const closeModal = () => {
        if (wakeLock) wakeLock.release(); // Release screen lock on close
        modalContainer.classList.add('hidden');
        modalContainer.classList.remove('flex');
    };
    modalContainer.querySelectorAll('.modal-close-btn').forEach(btn => btn.addEventListener('click', closeModal));
    
    // Feature: Wake Lock
    modalContainer.querySelector('#wakelock-btn').addEventListener('click', (e) => toggleWakeLock(e.currentTarget));

    // Feature: Share
    modalContainer.querySelector('#modal-share-btn').addEventListener('click', shareRecipe);

    modalContainer.querySelector('#modal-log-btn').addEventListener('click', () => showHistoryModal(recipe.id, recipe.name));
    modalContainer.querySelector('#modal-view-history-btn').addEventListener('click', () => showHistoryModal(recipe.id, recipe.name));
    modalContainer.querySelector('#modal-print-btn').addEventListener('click', () => printRecipe(recipe));

    modalContainer.querySelector('#modal-edit-btn').addEventListener('click', () => {
        closeModal();
        populateFormForEdit(recipeId);
    });

    modalContainer.querySelector('#modal-duplicate-btn').addEventListener('click', () => {
        closeModal();
        const recipeCopy = JSON.parse(JSON.stringify(recipe));
        delete recipeCopy.id; delete recipeCopy.createdAt; delete recipeCopy.updatedAt; delete recipeCopy.createdBy; delete recipeCopy.updatedBy; delete recipeCopy.importedAt; delete recipeCopy.importedFromUrl;
        recipeCopy.name = `Copy of ${recipe.name}`;
        populateFormForEdit(recipeCopy);
    });

    modalContainer.querySelector('#modal-delete-btn').addEventListener('click', async () => {
        if (confirm(`Delete "${recipe.name}"?`)) {
            try {
                const recipeRef = doc(db, 'users', userId, 'recipes', recipeId);
                await deleteDoc(recipeRef);
                closeModal();
                showNotification("Deleted.");
                loadRecipes(); 
            } catch (error) { console.error("Error deleting:", error); showNotification("Failed to delete.", "error"); }
        }
    });
    
    // Logic: Click to Strikethrough or Add Notes
    modalContainer.querySelector('#modal-content-area').addEventListener('click', async (e) => {
        const listItem = e.target.closest('li');
        if (!listItem) return;

            const noteDiv = e.target.closest('.italic');
        const isNoteClick = noteDiv && noteDiv.parentElement === listItem;

        if (e.target.closest('.add-note-btn') || isNoteClick) {
            e.stopPropagation();
            const type = listItem.dataset.type;
            const key = listItem.dataset.key;
            const encodedKey = createSafeKey(key);
            const noteMap = type === 'ingredient' ? 'ingredientNotes' : 'instructionNotes';
            
            const currentNote = recipe[noteMap][encodedKey] || '';
            const newNote = prompt(`Enter reminder for:\n"${key}"`, currentNote);

            if (newNote !== null) {
                try {
                    const recipeRef = doc(db, 'users', userId, 'recipes', recipeId);
                    const updatePayload = {};
                    updatePayload[`${noteMap}.${encodedKey}`] = newNote;
                    await updateDoc(recipeRef, updatePayload);
                    
                    recipe[noteMap][encodedKey] = newNote;
                    const noteContainer = listItem.querySelector('div');
                    if (noteContainer) noteContainer.remove();
                    if (newNote) {
                        listItem.insertAdjacentHTML('beforeend', renderNote(newNote));
                    }
                    showNotification("Note saved!");
                } catch (error) {
                    console.error("Error saving note: ", error);
                    showNotification("Failed to save note.", "error");
                }
            }
        } 
        else if (e.target.closest('span')) {
                listItem.classList.toggle('strikethrough');
        }
    });

    // Logic: Conversion and Scaling
    const unitSelect = modalContainer.querySelector('#unit-system-select');
    const scaleSelect = modalContainer.querySelector('#scale-select');

    const updateIngredientsDisplay = () => {
        const system = unitSelect.value;
        const scale = parseFloat(scaleSelect.value);
        convertAndRenderIngredients(recipe, system, scale);
    };

    unitSelect.addEventListener('change', updateIngredientsDisplay);
    scaleSelect.addEventListener('change', updateIngredientsDisplay);

    // Logic: Timer Click Handling
    const activeIntervals = new Map(); // Store intervals for this modal instance

    modalContainer.addEventListener('click', (e) => {
        const timerBtn = e.target.closest('.timer-btn');
        if (!timerBtn) return;
        
        e.stopPropagation(); // Prevent strikethrough logic

        if (timerBtn.classList.contains('running')) {
            // STOP Timer
            clearInterval(activeIntervals.get(timerBtn));
            activeIntervals.delete(timerBtn);
            timerBtn.classList.remove('running');
            timerBtn.innerHTML = `<i class="fas fa-stopwatch"></i> ${timerBtn.dataset.originalText}`;
        } else if (timerBtn.classList.contains('finished')) {
            // RESET Timer
            timerBtn.classList.remove('finished');
            timerBtn.innerHTML = `<i class="fas fa-stopwatch"></i> ${timerBtn.dataset.originalText}`;
        } else {
            // START Timer
            const duration = parseInt(timerBtn.dataset.millis);
            const endTime = Date.now() + duration;
            
            timerBtn.classList.add('running');
            
            const updateTimer = () => {
                const remaining = endTime - Date.now();
                if (remaining <= 0) {
                    clearInterval(activeIntervals.get(timerBtn));
                    activeIntervals.delete(timerBtn);
                    timerBtn.classList.remove('running');
                    timerBtn.classList.add('finished');
                    timerBtn.innerHTML = `<i class="fas fa-bell"></i> Done!`;
                    playTimerSound();
                    
                    // Optional: Browser Notification
                    if (Notification.permission === "granted") {
                        new Notification(`Timer Done: ${recipe.name}`, { body: "Your step timer has finished!" });
                    }
                } else {
                    const totalSeconds = Math.ceil(remaining / 1000);
                    const m = Math.floor(totalSeconds / 60);
                    const s = totalSeconds % 60;
                    const timeStr = m > 0 ? `${m}m ${s}s` : `${s}s`;
                    timerBtn.innerHTML = `<i class="fas fa-hourglass-half"></i> ${timeStr}`;
                }
            };
            
            updateTimer(); // Initial call
            const intervalId = setInterval(updateTimer, 1000);
            activeIntervals.set(timerBtn, intervalId);

            // Request Notification Permission if needed
            if (Notification.permission === "default") {
                Notification.requestPermission();
            }
        }
    });

    // Cleanup intervals when modal closes
    const originalCloseModal = closeModal; // Capture the closure defined earlier
    const cleanupAndClose = () => {
        activeIntervals.forEach(id => clearInterval(id));
        activeIntervals.clear();
        originalCloseModal();
    };
    // Re-attach close listeners to use the cleanup version
    modalContainer.querySelectorAll('.modal-close-btn').forEach(btn => {
        btn.removeEventListener('click', closeModal); // Remove old
        btn.addEventListener('click', cleanupAndClose); // Add new
    });

    modalContainer.classList.remove('hidden');
    modalContainer.classList.add('flex');
}

            async function showHistoryModal(recipeId, recipeName) {
                let historyRating = 0;

                historyModalContainer.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 rounded-none md:rounded-lg shadow-2xl w-full h-full md:h-auto md:max-h-[90vh] max-w-5xl flex flex-col">
                        <div class="p-4 border-b dark:border-gray-700 flex justify-between items-center">
                            <h3 class="text-2xl font-bold">Cooking Log for ${recipeName}</h3>
                            <button id="close-history-modal-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"><i class="fas fa-times text-xl"></i></button>
                        </div>
                        <div class="p-6 grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4 flex-grow overflow-hidden">
                            <div class="flex flex-col space-y-4">
                                <h4 class="text-xl font-bold">Add New Log</h4>
                                <form id="add-history-form" class="space-y-3">
                                    <div>
                                        <label for="history-date" class="block text-sm font-medium">Date Cooked</label>
                                        <input type="date" id="history-date" required class="mt-1 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                                    </div>
                                    <div>
    <label for="history-scale" class="block text-sm font-medium">Portions Cooked (Scale)</label>
    <div class="flex items-center gap-2 mt-1">
        <select id="history-scale" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
            <option value="0.5">0.5x (Half)</option>
            <option value="1" selected>1x (Standard)</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x (Double)</option>
            <option value="3">3x (Triple)</option>
            <option value="4">4x (Quadruple)</option>
        </select>
    </div>
</div>
                                    <div>
                                        <label class="block text-sm font-medium">Rating</label>
                                        <div id="history-rating-input" class="flex items-center gap-1 mt-1"></div>
                                    </div>
                                    <div>
                                        <label for="history-notes" class="block text-sm font-medium">Notes (changes, results, etc.)</label>
                                        <textarea id="history-notes" rows="4" class="mt-1 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full"></textarea>
                                    </div>
                                    <div>
                                        <label for="history-appliance-select" class="block text-sm font-medium">Appliance Used</label>
                                        <select id="history-appliance-select" class="mt-1 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 w-full">
                                            <option value="">None / Not Specified</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label for="history-image-upload" class="block text-sm font-medium">Photo of this Cook</label>
                                        <input type="file" id="history-image-upload" accept="image/*" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                                    </div>
                                    <button type="submit" id="save-history-btn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Save Log</button>
                                </form>
                            </div>
                            <div class="flex flex-col overflow-hidden">
                                <h4 class="text-xl font-bold mb-2">Past Entries</h4>
                                <div id="history-log-list" class="flex-grow overflow-y-auto space-y-4 pr-2 -mr-2">
                                    <p class="text-gray-500">Loading history...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('history-date').valueAsDate = new Date();

                const applianceSelect = document.getElementById('history-appliance-select');
                if (applianceSelect) {
                    appliancesCache.forEach(appliance => {
                        applianceSelect.innerHTML += `<option value="${appliance.id}">${appliance.name}</option>`;
                    });
                }

                const renderHistoryRatingInput = (rating) => {
                    const container = document.getElementById('history-rating-input');
                    container.innerHTML = '';
                    historyRating = rating;
                    for (let i = 1; i <= 5; i++) {
                        const star = document.createElement('i');
                        star.className = `fas fa-star cursor-pointer text-2xl ${i <= rating ? 'text-yellow-400' : 'text-gray-300'}`;
                        star.addEventListener('click', () => renderHistoryRatingInput(i));
                        container.appendChild(star);
                    }
                };
                renderHistoryRatingInput(0);

                const historyListEl = document.getElementById('history-log-list');
                const historyCol = collection(db, 'users', userId, 'recipes', recipeId, 'history');
                const q = query(historyCol, orderBy('cookedAt', 'desc'));
                const historySnapshot = await getDocs(q);
                
                if (historySnapshot.empty) {
                    historyListEl.innerHTML = '<p class="text-gray-500">No cooking history found. Add your first log!</p>';
                } else {
                    historyListEl.innerHTML = '';
                    historySnapshot.docs.forEach(doc => {
                        const log = doc.data();
                        const appliance = appliancesCache.find(a => a.id === log.applianceId);
                        const applianceText = appliance ? `${appliance.name} ${appliance.location ? `(${appliance.location})` : ''}` : 'N/A';
                        const cookedDate = log.cookedAt ? new Date(log.cookedAt).toLocaleDateString() : 'N/A';
                        const ratingHtml = Array.from({length: 5}, (_, i) => `<i class="fas fa-star ${i < log.rating ? 'text-yellow-400' : 'text-gray-300'}"></i>`).join('');
                        
                        const logEl = document.createElement('div');
                        logEl.className = "border-t dark:border-gray-700 pt-4";
                        logEl.innerHTML = `
                            ${log.imageUrl ? `<img src="${log.imageUrl}" class="w-full h-40 object-cover rounded-md mb-2">` : ''}
                            <div class="flex justify-between items-center text-sm">
                                <p class="font-bold">Cooked on: ${cookedDate}</p>
                                <div class="flex">${ratingHtml}</div>
                            </div>
                            <p class="text-sm mt-1"><strong>Appliance:</strong> ${applianceText}</p>
                            <p class="text-sm mt-2 bg-gray-100 dark:bg-gray-900 p-2 rounded">${log.notes || 'No notes for this entry.'}</p>
                        `;
                        historyListEl.appendChild(logEl);
                    });
                }

                document.getElementById('add-history-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const saveBtn = document.getElementById('save-history-btn');
                    saveBtn.disabled = true; saveBtn.textContent = "Saving...";
                    try {
                        let imageUrl = '';
                        const imageFile = document.getElementById('history-image-upload').files[0];
                        if (imageFile) {
                            const imageRef = ref(storage, `users/${userId}/recipes/${recipeId}/history/${Date.now()}_${imageFile.name}`);
                            await uploadBytes(imageRef, imageFile);
                            imageUrl = await getDownloadURL(imageRef);
                        }
                        const selectedApplianceEl = document.getElementById('history-appliance-select');
                        const applianceId = selectedApplianceEl.value;
                        const applianceName = applianceId ? selectedApplianceEl.options[selectedApplianceEl.selectedIndex].text : null;

                        const historyData = {
                            cookedAt: document.getElementById('history-date').value,
                            rating: historyRating,
                            notes: document.getElementById('history-notes').value,
                            scaleCooked: document.getElementById('history-scale').value,
                            imageUrl,
                            applianceId: applianceId || null,
                            applianceName: applianceName || null,
                            createdAt: serverTimestamp()
                        };
                        const historyColRef = collection(db, 'users', userId, 'recipes', recipeId, 'history');
                        await addDoc(historyColRef, historyData);
                        // [INSERT THIS CODE IMMEDIATELY AFTER addDoc]
    // Update parent recipe with lastCooked date for Dashboard visibility
    const recipeRef = doc(db, 'users', userId, 'recipes', recipeId);
    await updateDoc(recipeRef, { 
        lastCooked: historyData.cookedAt, // Stores YYYY-MM-DD
        lastCookedImage: historyData.imageUrl || null
    });
                        showNotification("Cooking log saved successfully!");
                        closeHistoryModal();
                    } catch (error) { console.error("Error saving history log:", error); showNotification("Failed to save log.", "error"); }
                    finally { saveBtn.disabled = false; saveBtn.textContent = "Save Log"; }
                });

                const closeHistoryModal = () => { historyModalContainer.classList.add('hidden'); historyModalContainer.classList.remove('flex'); };
                document.getElementById('close-history-modal-btn').addEventListener('click', closeHistoryModal);
                
                historyModalContainer.classList.remove('hidden');
                historyModalContainer.classList.add('flex');
            }
            
            function showAppliancesModal() {
                appliancesModalContainer.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 rounded-none md:rounded-lg shadow-2xl w-full h-full md:h-auto md:max-h-[90vh] max-w-lg flex flex-col">
                        <div class="p-4 border-b dark:border-gray-700 flex justify-between items-center">
                            <h3 class="text-2xl font-bold">Manage Your Appliances</h3>
                            <button id="close-appliances-modal-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"><i class="fas fa-times text-xl"></i></button>
                        </div>
                        <div class="p-6 flex-grow overflow-y-auto">
                            <form id="add-appliance-form" class="space-y-4 mb-6">
                                <input type="text" id="appliance-name-input" placeholder="Appliance Name (e.g., Ninja Air Fryer)" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600" required>
                                <input type="text" id="appliance-location-input" placeholder="Storage Location (e.g., Kitchen Counter)" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                <div>
                                    <label for="appliance-purchase-date-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Date Purchased</label>
                                    <input type="date" id="appliance-purchase-date-input" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
                                </div>
                                <button type="submit" class="w-full bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">Add Appliance</button>
                            </form>
                            <h4 class="text-xl font-bold mb-2">Registered Appliances</h4>
                            <div id="appliance-list" class="space-y-2"></div>
                        </div>
                    </div>
                `;

                const applianceListEl = appliancesModalContainer.querySelector('#appliance-list');

                function renderAppliances() {
                    if (appliancesCache.length === 0) {
                        applianceListEl.innerHTML = '<p class="text-gray-500">You have no registered appliances.</p>';
                        return;
                    }
                    applianceListEl.innerHTML = appliancesCache.map(appliance => `
                        <div class="flex justify-between items-center p-3 bg-gray-100 dark:bg-gray-900 rounded-lg">
                            <div>
                                <p class="font-semibold">${appliance.name}</p>
                                <p class="text-sm text-gray-500 dark:text-gray-400">
                                    Location: ${appliance.location || 'N/A'} | Purchased: ${appliance.purchaseDate || 'N/A'}
                                </p>
                            </div>
                            <div>
                                <button data-id="${appliance.id}" class="edit-appliance-btn text-blue-500 hover:text-blue-700 mr-2"><i class="fas fa-edit"></i></button>
                                <button data-id="${appliance.id}" class="delete-appliance-btn text-red-500 hover:text-red-700"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                    `).join('');
                }

                renderAppliances();

                const closeAppliancesModal = () => {
                    appliancesModalContainer.classList.add('hidden');
                    appliancesModalContainer.classList.remove('flex');
                };
                 const resetApplianceForm = () => {
                    const form = document.getElementById('add-appliance-form');
                    form.reset();
                    delete form.dataset.editingId;
                    const submitBtn = form.querySelector('button[type="submit"]');
                    submitBtn.textContent = 'Add Appliance';
                    submitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    submitBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                    document.getElementById('cancel-appliance-edit-btn')?.remove();
                };


                appliancesModalContainer.querySelector('#close-appliances-modal-btn').addEventListener('click', closeAppliancesModal);

                appliancesModalContainer.querySelector('#add-appliance-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const form = e.target;
                    const editingId = form.dataset.editingId;
                    const name = document.getElementById('appliance-name-input').value.trim();
                    const location = document.getElementById('appliance-location-input').value.trim();
                    const purchaseDate = document.getElementById('appliance-purchase-date-input').value;
                    
                    if (name && userId) {
                        try {
                            if (editingId) {
                                const applianceRef = doc(db, `users/${userId}/appliances`, editingId);
                                await updateDoc(applianceRef, { name, location, purchaseDate });
                                showNotification("Appliance updated!");
                            } else {
                                const appliancesCol = collection(db, 'users', userId, 'appliances');
                                await addDoc(appliancesCol, { name, location, purchaseDate, createdAt: serverTimestamp() });
                                showNotification("Appliance added!");
                            }
                            resetApplianceForm();
                            await loadAppliances();
                            renderAppliances();
                        } catch (error) {
                            console.error("Error saving appliance:", error);
                            showNotification("Failed to save appliance.", "error");
                        }
                    }
                });

                applianceListEl.addEventListener('click', async (e) => {
                    const deleteBtn = e.target.closest('.delete-appliance-btn');
                    const editBtn = e.target.closest('.edit-appliance-btn');

                    if (deleteBtn && userId) {
                        const applianceId = deleteBtn.dataset.id;
                        if (confirm("Are you sure you want to delete this appliance?")) {
                            try {
                                await deleteDoc(doc(db, 'users', userId, 'appliances', applianceId));
                                showNotification("Appliance deleted.");
                                await loadAppliances();
                                renderAppliances();
                            } catch (error) {
                                console.error("Error deleting appliance:", error);
                                showNotification("Failed to delete appliance.", "error");
                            }
                        }
                    } else if (editBtn && userId) {
                        const applianceId = editBtn.dataset.id;
                        const appliance = appliancesCache.find(a => a.id === applianceId);
                        if (appliance) {
                            document.getElementById('appliance-name-input').value = appliance.name;
                            document.getElementById('appliance-location-input').value = appliance.location || '';
                            document.getElementById('appliance-purchase-date-input').value = appliance.purchaseDate || '';
                            
                            const form = document.getElementById('add-appliance-form');
                            form.dataset.editingId = applianceId;
                            const submitBtn = form.querySelector('button[type="submit"]');
                            submitBtn.textContent = 'Save Changes';
                            submitBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                            submitBtn.classList.add('bg-green-600', 'hover:bg-green-700');

                            if (!document.getElementById('cancel-appliance-edit-btn')) {
                                const cancelBtn = document.createElement('button');
                                cancelBtn.type = 'button';
                                cancelBtn.id = 'cancel-appliance-edit-btn';
                                cancelBtn.textContent = 'Cancel Edit';
                                cancelBtn.className = 'w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600';
                                cancelBtn.addEventListener('click', resetApplianceForm);
                                form.appendChild(cancelBtn);
                            }
                        }
                    }
                });

                appliancesModalContainer.classList.remove('hidden');
                appliancesModalContainer.classList.add('flex');
            }

            function renderModalRating(recipeId, rating) {
                const container = modalContainer.querySelector('.modal-rating-stars');
                if(!container) return;
                container.innerHTML = '';
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement('i');
                    star.className = `fas fa-star cursor-pointer text-2xl ${i <= rating ? 'text-yellow-400' : 'text-gray-300'}`;
                    star.dataset.value = i;
                    star.addEventListener('click', async () => {
                        const newRating = Number(star.dataset.value);
                        try {
                            const recipeRef = doc(db, 'users', userId, 'recipes', recipeId);
                            await updateDoc(recipeRef, { rating: newRating, updatedAt: serverTimestamp() });
                            const recipeInCache = recipesCache.find(r => r.id === recipeId);
                            if(recipeInCache) recipeInCache.rating = newRating;
                            renderModalRating(recipeId, newRating);
                            showNotification("Rating updated!");
                        } catch (error) { console.error("Error updating rating:", error); showNotification("Failed to update rating.", "error"); }
                    });
                    container.appendChild(star);
                }
            }

            function renderModalLabels(recipe) {
                const container = modalContainer.querySelector('#modal-labels-container');
                container.innerHTML = '';
                (recipe.labels || []).forEach(label => {
                    container.innerHTML += `<span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${label}</span>`;
                });
                container.innerHTML += `<button id="modal-edit-labels-btn" class="text-indigo-500 hover:text-indigo-700 ml-2 text-xs"><i class="fas fa-edit"></i></button>`;
                
                modalContainer.querySelector('#modal-edit-labels-btn').addEventListener('click', () => {
                    const currentLabels = (recipe.labels || []).join(', ');
                    const newLabelsStr = prompt('Edit labels (comma-separated):', currentLabels);
                    if (newLabelsStr !== null) {
                        const newLabels = newLabelsStr.split(',').map(l => l.trim()).filter(Boolean);
                        updateRecipeField(recipe.id, { labels: newLabels }).then(() => {
                            let recipeInCache = recipesCache.find(r => r.id === recipe.id);
                            if (recipeInCache) recipeInCache.labels = newLabels;
                            recipe.labels = newLabels;
                            renderModalLabels(recipe);
                            showNotification('Labels updated!');
                        });
                    }
                });
            }

             function renderLinkedRecipes(recipeId) {
                const recipe = recipesCache.find(r => r.id === recipeId);
                const container = document.getElementById('linked-recipes-list');
                container.innerHTML = '';
                if (recipe && recipe.linkedRecipeIds && recipe.linkedRecipeIds.length > 0) {
                    recipe.linkedRecipeIds.forEach(linkedId => {
                        const linkedRecipe = recipesCache.find(r => r.id === linkedId);
                        if (linkedRecipe) {
                            const linkEl = document.createElement('a');
                            linkEl.href = '#';
                            linkEl.textContent = linkedRecipe.name;
                            linkEl.className = 'block text-sm text-indigo-500 hover:underline';
                            linkEl.addEventListener('click', (e) => {
                                e.preventDefault();
                                showRecipeDetailsModal(linkedId);
                            });
                            container.appendChild(linkEl);
                        }
                    });
                } else {
                    container.innerHTML = '<p class="text-sm text-gray-500">No linked recipes.</p>';
                }
            }

function renderReadOnlyRating(rating) {
    const container = modalContainer.querySelector('.modal-rating-stars');
    if(!container) return;
    container.innerHTML = '';
    for (let i = 1; i <= 5; i++) {
        const star = document.createElement('i');
        // Removed 'cursor-pointer' and click listener
        star.className = `fas fa-star text-lg ${i <= rating ? 'text-yellow-400' : 'text-gray-300'}`;
        container.appendChild(star);
    }
}

            function renderApprovals(recipeId, approvals) {
                const container = document.getElementById('approvals-list');
                container.innerHTML = '';
                (approvals || []).forEach(name => {
                    const approvalEl = document.createElement('span');
                    approvalEl.className = 'bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 text-xs px-2 py-1 rounded-full flex items-center gap-1';
                    approvalEl.innerHTML = `${name} <button data-name="${name}" class="remove-approval-btn text-red-500 hover:text-red-700 text-xs"><i class="fas fa-times-circle"></i></button>`;
                    container.appendChild(approvalEl);
                });

                container.querySelectorAll('.remove-approval-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const nameToRemove = e.currentTarget.dataset.name;
                        const newApprovals = (approvals || []).filter(name => name !== nameToRemove);
                        await updateRecipeField(recipeId, { approvals: newApprovals });
                        let recipeInCache = recipesCache.find(r => r.id === recipeId);
                        if (recipeInCache) recipeInCache.approvals = newApprovals;
                        renderApprovals(recipeId, newApprovals);
                        showNotification('Approval removed!');
                    });
                });

                document.getElementById('add-approval-btn').onclick = async () => {
                    const input = document.getElementById('approval-name-input');
                    const newName = input.value.trim();
                    if (newName) {
                        const newApprovals = [...(approvals || []), newName];
                        await updateRecipeField(recipeId, { approvals: newApprovals });
                        let recipeInCache = recipesCache.find(r => r.id === recipeId);
                        if (recipeInCache) recipeInCache.approvals = newApprovals;
                        renderApprovals(recipeId, newApprovals);
                        input.value = '';
                        showNotification('Approval added!');
                    }
                };
            }

            async function updateRecipeField(recipeId, fieldsToUpdate) {
                if (!userId || !recipeId) return;
                try {
                    const recipeRef = doc(db, 'users', userId, 'recipes', recipeId);
                    await updateDoc(recipeRef, { ...fieldsToUpdate, updatedAt: serverTimestamp() });
                } catch (error) {
                    console.error("Error updating recipe field:", error);
                    showNotification("Failed to update recipe.", "error");
                    throw error;
                }
            }
            
            function convertAndRenderIngredients(recipe, system, scale = 1) {
    const ingredientsData = processData(recipe.ingredients, 'Ingredients');
    let convertedHtml = '';

    ingredientsData.forEach(section => {
        convertedHtml += `<h5 class="font-bold mt-3 text-gray-500 dark:text-gray-400 uppercase text-sm">${section.section}</h5>`;
        convertedHtml += `<ul class="list-none space-y-2 mt-1 pl-2">`;
        (section.items || []).forEach(item => {
            const originalText = (typeof item === 'string') ? item : item.text;
            if (!originalText) return;

            // 1. First Scale
            let processedText = scaleIngredientString(originalText, scale);

            // 2. Then Convert Unit (if needed)
            // Note: convertIngredientString needs to parse the ALREADY scaled number now
            if (system !== 'original') {
                processedText = convertIngredientString(processedText, system);
            }
            
            const tipHtml = (typeof item === 'object' && item.tip) ? `<span class="text-xs text-gray-400 italic">(${item.tip})</span>` : '';
            const noteKey = (typeof item === 'object') ? item.text : item;
            const noteHtml = recipe.ingredientNotes && recipe.ingredientNotes[createSafeKey(noteKey)] ? renderNote(recipe.ingredientNotes[createSafeKey(noteKey)]) : '';
            
            convertedHtml += `<li data-type="ingredient" data-key="${noteKey}" class="relative pl-4 before:content-['â€¢'] before:absolute before:left-0 group">
                <span class="cursor-pointer hover:text-gray-500">${processedText} ${tipHtml}</span>
                <button class="add-note-btn opacity-0 group-hover:opacity-100 transition-opacity text-indigo-500 hover:text-indigo-700 ml-2"><i class="fas fa-plus-circle"></i></button>
                ${noteHtml}
            </li>`;
        });
        convertedHtml += `</ul>`;
    });
    
    document.getElementById('modal-ingredients').innerHTML = convertedHtml;
}

            function scaleIngredientString(itemText, scaleFactor) {
    if (typeof itemText !== 'string' || scaleFactor === 1) return itemText;

    // Regex to find numbers at the start of the string (integers, decimals, fractions like 1/2 or 1 1/2)
    // This looks for: start of line -> optional number -> optional space -> fraction OR standard decimal/int
    const regex = /^((?:\d+\s+)?\d+\/\d+|\d+(\.\d+)?)/;
    
    const match = itemText.match(regex);
    if (!match) return itemText;

    let originalNumber = 0;
    const numberStr = match[0].trim();

    // Handle Fractions (e.g., "1/2" or "1 1/2")
    if (numberStr.includes('/')) {
        const parts = numberStr.split(' ');
        let fraction = parts.length > 1 ? parts[1] : parts[0];
        let whole = parts.length > 1 ? parseFloat(parts[0]) : 0;
        
        const [num, den] = fraction.split('/').map(parseFloat);
        originalNumber = whole + (num / den);
    } else {
        // Handle decimals/integers
        originalNumber = parseFloat(numberStr);
    }

    if (isNaN(originalNumber)) return itemText;

    // Calculate new amount
    let newAmount = originalNumber * scaleFactor;

    // formatting: if it's a whole number, don't show decimals. If decimal, max 2 places.
    // Ideally, convert 0.5 back to 1/2, but for simplicity, we'll stick to decimals for now.
    let formattedAmount = Number.isInteger(newAmount) ? newAmount.toString() : newAmount.toFixed(2).replace(/\.00$/, '').replace(/0+$/, '');

    // Replace the old number with the new scaled number
    return itemText.replace(numberStr, formattedAmount);
}
            
            function convertIngredientString(itemText, system) {
                if (typeof itemText !== 'string') return itemText;

                const regex = /(\d+\.?\d*|\d+)\s*(g|grams|tsp|teaspoons|tbsp|tablespoons|cup|cups)\b/i;
                const match = itemText.match(regex);
                if (!match) return itemText;

                const quantity = parseFloat(match[1]);
                const unit = match[2].toLowerCase();
                let convertedQuantity, newUnit;

                switch(unit) {
                    case 'g': case 'grams':
                        if (system === 'us_customary') {
                            convertedQuantity = (quantity * CONVERSIONS.G_TO_OZ).toFixed(1);
                            newUnit = 'oz';
                            return itemText.replace(match[0], `${convertedQuantity} ${newUnit}`);
                        }
                        break;
                    case 'tsp': case 'teaspoons':
                        if (system !== 'original') {
                            convertedQuantity = (quantity * CONVERSIONS.TSP_TO_ML.metric).toFixed(1);
                            newUnit = 'mL';
                            return itemText.replace(match[0], `${convertedQuantity} ${newUnit}`);
                        }
                        break;
                    case 'tbsp': case 'tablespoons':
                        if (CONVERSIONS.TBSP_TO_ML[system]) {
                            convertedQuantity = (quantity * CONVERSIONS.TBSP_TO_ML[system]).toFixed(1);
                            newUnit = 'mL';
                            return itemText.replace(match[0], `${convertedQuantity} ${newUnit}`);
                        }
                        break;
                    case 'cup': case 'cups':
                        if (system === 'us_customary' || system === 'uk_metric' || system === 'au_metric') {
                            const targetSystem = (system === 'us_customary') ? 'us_customary' : 'metric';
                            convertedQuantity = (quantity * CONVERSIONS.CUP_TO_ML[targetSystem]).toFixed(0);
                            newUnit = 'mL';
                            return itemText.replace(match[0], `${convertedQuantity} ${newUnit}`);
                        }
                        break;
                }
                return itemText;
            }

            function loadPreferences() {
                currentLayout = localStorage.getItem('recipeLayout') || 'tiles';
                currentSort = localStorage.getItem('recipeSort') || 'title-asc';
                const savedOptions = localStorage.getItem('recipeDisplayOptions');
                if (savedOptions) {
                    displayOptions = JSON.parse(savedOptions);
                }
                layoutSelect.value = currentLayout;
                sortBySelect.value = currentSort;
                Object.keys(displayOptions).forEach(key => {
                    const toggle = document.getElementById(`${key.replace(/([A-Z])/g, "-$1").toLowerCase()}-toggle`);
                    if (toggle) toggle.checked = displayOptions[key];
                });
            }

            function savePreferences() {
                localStorage.setItem('recipeLayout', currentLayout);
                localStorage.setItem('recipeSort', currentSort);
                localStorage.setItem('recipeDisplayOptions', JSON.stringify(displayOptions));
            }

            function updateMultiSelectUI() {
                appContainer.classList.toggle('multi-select-mode', isMultiSelectMode);
                bulkActionsBar.classList.toggle('hidden', !isMultiSelectMode);
                multiSelectBtn.textContent = isMultiSelectMode ? 'Cancel Selection' : 'Select Multiple Recipes';
                if (!isMultiSelectMode) {
                    optionsPanel.classList.add('hidden');
                }
                selectionCountEl.textContent = `${selectedRecipeIds.size} recipes selected`;
            }

            function parseISODurationToMinutes(isoDuration) {
                if (!isoDuration || typeof isoDuration !== 'string') return 0;
                const regex = /PT(?:(\d+)H)?(?:(\d+)M)?/;
                const matches = isoDuration.match(regex);
                if (!matches) return 0;
                const hours = parseInt(matches[1] || 0, 10);
                const minutes = parseInt(matches[2] || 0, 10);
                return (hours * 60) + minutes;
            }

            function getImageUrl(image) {
                if (!image) return null;
                if (typeof image === 'string') return image;
                if (Array.isArray(image)) {
                    const firstImage = image[0];
                    if(typeof firstImage === 'string') return firstImage;
                    if(typeof firstImage === 'object' && firstImage.url) return firstImage.url;
                }
                if (typeof image === 'object' && image.url) return image.url;
                return null;
            }
            
            function textDurationToISO(text) {
                if (!text || typeof text !== 'string') return null;
                let hours = 0;
                let minutes = 0;
                const hourMatch = text.match(/(\d+)\s*(?:hours?|hr)/i);
                const minMatch = text.match(/(\d+)\s*(?:minutes?|mins?)/i);
                
                if (hourMatch) hours = parseInt(hourMatch[1], 10);
                if (minMatch) minutes = parseInt(minMatch[1], 10);
                
                if (!hourMatch && !minMatch && /^\d+$/.test(text.trim())) {
                    minutes = parseInt(text.trim(), 10);
                }
                
                if (hours === 0 && minutes === 0) return null;

                let duration = 'PT';
                if (hours > 0) duration += `${hours}H`;
                if (minutes > 0) duration += `${minutes}M`;
                return duration;
            }

            function normalizeJsonLdStructure(data, defaultSectionName) {
                if (!Array.isArray(data)) return [{ section: defaultSectionName, items: [] }];

                const sections = [];
                let currentSection = { section: defaultSectionName, items: [] };

                data.forEach(item => {
                    if (typeof item === 'object' && item !== null && item['@type'] === 'HowToSection') {
                        if (currentSection.items.length > 0) {
                            sections.push(currentSection);
                        }
                        currentSection = { section: item.text.replace(/\[|\]|:/g, '').trim(), items: [] };
                    } else if (typeof item === 'object' && item !== null && item['@type'] === 'HowToStep') {
                        currentSection.items.push({ text: item.text });
                    } else if (typeof item === 'string') {
                        const match = item.trim().match(/^\[(.*?)\]:?$/);
                        if (match && item.trim().endsWith(']')) {
                             if (currentSection.items.length > 0) {
                                sections.push(currentSection);
                            }
                            currentSection = { section: match[1].trim(), items: [] };
                        } else {
                            currentSection.items.push({ text: item });
                        }
                    }
                });
                
                if (currentSection.items.length > 0 || sections.length === 0) {
                    sections.push(currentSection);
                }
                return sections;
            }
            
            function parseRecipeSageTxt(txtContent) {
                const recipes = [];
                let content = txtContent.trim().replace(/\r\n/g, '\n');
                
                const lines = content.split('\n');
                let firstRecipeTitleFromHeader = '';
                if (lines.length > 0 && lines[0].trim().startsWith('==== Recipes ====')) {
                    firstRecipeTitleFromHeader = lines[0].replace(/^==== Recipes ====/, '').replace(/^-/, '').trim();
                    lines.shift();
                    content = lines.join('\n');
                }

                const recipeBlocks = content.split(/^\s*---\s*$/m);

                recipeBlocks.forEach((block, index) => {
                    const trimmedBlock = block.trim();
                    if (!trimmedBlock) return;

                    const recipe = {
                        recipeIngredient: [],
                        recipeInstructions: [],
                        comment: [],
                        keywords: []
                    };
                    let blockLines = trimmedBlock.split('\n');
                    let currentSection = 'meta';
                    let currentSectionData = null;

                    // Handle Title
                    if (index === 0 && firstRecipeTitleFromHeader) {
                        recipe.name = firstRecipeTitleFromHeader;
                    } else {
                        const titleLineIndex = blockLines.findIndex(line => line.trim() !== '');
                        if (titleLineIndex !== -1) {
                            recipe.name = blockLines[titleLineIndex].trim();
                            blockLines = blockLines.slice(titleLineIndex + 1);
                        } else {
                            return; 
                        }
                    }
                    if (recipe.name.toLowerCase().startsWith('title:')) {
                        recipe.name = recipe.name.substring(6).trim();
                    }

                    for (const line of blockLines) {
                        const trimmedLine = line.trim();
                        if (!trimmedLine) {
                            currentSection = 'meta';
                            continue;
                        }

                        const separatorIndex = trimmedLine.indexOf(':');
                        if (currentSection === 'meta' && separatorIndex > 0) {
                            const key = trimmedLine.substring(0, separatorIndex).toLowerCase().trim();
                            const value = trimmedLine.substring(separatorIndex + 1).trim();
                            
                            let keyProcessed = true;
                            switch (key) {
                                case 'description': recipe.description = value; break;
                                case 'source': recipe.creditText = value; break;
                                case 'url': recipe.url = value; break;
                                case 'yield': case 'servings': recipe.recipeYield = value; break;
                                case 'prep time': case 'prep': recipe.prepTime = textDurationToISO(value); break;
                                case 'cook time': case 'cook': recipe.cookTime = textDurationToISO(value); break;
                                case 'total time': case 'total': recipe.totalTime = textDurationToISO(value); break;
                                case 'tags': case 'folders': recipe.keywords = value.split(/[,/]/).map(k => k.trim()).filter(Boolean); break;
                                case 'createdat': recipe.datePublished = new Date(value).toISOString(); break;
                                case 'updatedat': recipe.dateModified = new Date(value).toISOString(); break;
                                case 'rating': recipe.rating = parseInt(value, 10) || 0; break;
                                default: keyProcessed = false; break;
                            }
                            if (keyProcessed) continue;
                        }

                        const lowerLine = trimmedLine.toLowerCase();
                        if (lowerLine === 'ingredients') {
                            currentSection = 'ingredients';
                            currentSectionData = { section: 'Ingredients', items: [] };
                            if (!recipe.recipeIngredient.find(s => s.section === 'Ingredients')) recipe.recipeIngredient.push(currentSectionData);
                            continue;
                        }
                        if (lowerLine.startsWith('direction') || lowerLine === 'instructions') {
                            currentSection = 'instructions';
                            currentSectionData = { section: 'Instructions', items: [] };
                            if (!recipe.recipeInstructions.find(s => s.section === 'Instructions')) recipe.recipeInstructions.push(currentSectionData);
                            continue;
                        }
                        if (lowerLine === 'notes') {
                            currentSection = 'notes';
                            currentSectionData = [];
                            recipe.comment = currentSectionData;
                            continue;
                        }

                        if (trimmedLine === trimmedLine.toUpperCase() && !trimmedLine.match(/\d/) && separatorIndex === -1 && trimmedLine.length > 1) {
                            if (currentSection !== 'instructions') {
                                currentSection = 'ingredients';
                                currentSectionData = { section: trimmedLine, items: [] };
                                recipe.recipeIngredient.push(currentSectionData);
                            } else {
                                currentSection = 'instructions';
                                currentSectionData = { section: trimmedLine, items: [] };
                                recipe.recipeInstructions.push(currentSectionData);
                            }
                            continue;
                        }
                        
                        if (currentSection === 'ingredients' && currentSectionData) {
                            currentSectionData.items.push({ text: trimmedLine.replace(/^- /, '') });
                        } else if (currentSection === 'instructions' && currentSectionData) {
                            currentSectionData.items.push({ text: trimmedLine.replace(/^\d+\.\s*/, '') });
                        } else if (currentSection === 'notes' && currentSectionData) {
                            currentSectionData.push({ text: trimmedLine });
                        }
                    }

                    if (recipe.name) {
                        recipes.push(recipe);
                    }
                });

                return recipes;
            }

            async function handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const btnToDisable = event.target.id === 'import-file-input' ? fetchUrlBtn : importFileInput;
                btnToDisable.disabled = true;
                showNotification(`Processing ${file.name}...`, 'info');
                importReviewSection.classList.add('hidden');

                try {
                    const content = await file.text();
                    const fileType = file.name.split('.').pop().toLowerCase();
                    
                    if (fileType === 'txt') {
                        fetchedRecipesCache = parseRecipeSageTxt(content);
                    } else if (fileType === 'json' || fileType === 'jsonld') {
                        const data = JSON.parse(content);
                        fetchedRecipesCache = data.recipes || (Array.isArray(data) ? data : [data]);
                    } else {
                        throw new Error("Unsupported file type.");
                    }

                    if (!fetchedRecipesCache || fetchedRecipesCache.length === 0) {
                        showNotification('No recipes found in the file.', 'error');
                        return;
                    }

                    importSummaryText.textContent = `Found ${fetchedRecipesCache.length} recipe(s) in this file.`;
                    batchImportBtn.textContent = `Import All (${fetchedRecipesCache.length} recipes)`;
                    importReviewSection.classList.remove('hidden');

                } catch (error) {
                    console.error('File import failed:', error);
                    showNotification(`Failed to process file: ${error.message}`, 'error');
                } finally {
                    btnToDisable.disabled = false;
                    event.target.value = ''; // Reset file input
                }
            }


            function populateFormWithImportedData(recipe) {
                form.reset();
                currentRating = 0;
                renderAddRatingStars();
                editingRecipeId = null;
                importedImageUrl = null;
                document.getElementById('form-buttons').querySelector('#cancel-edit-btn')?.remove();

                const imagePreview = document.getElementById('image-preview');
                importedImageUrl = getImageUrl(recipe.image);
                if (importedImageUrl) {
                    imagePreview.src = importedImageUrl;
                    imagePreview.classList.remove('hidden');
                } else {
                    imagePreview.classList.add('hidden');
                }

                document.getElementById('recipe-name').value = recipe.name || '';
                document.getElementById('recipe-description').value = recipe.description || '';
                document.getElementById('recipe-cuisine').value = recipe.recipeCuisine || '';
                document.getElementById('recipe-source-url').value = recipe.isBasedOn || recipe.url || '';
                
                let sourceName = '';
                if(typeof recipe.author === 'object' && recipe.author !== null) {
                    sourceName = recipe.author.name || '';
                } else if (recipe.author) {
                    sourceName = recipe.author;
                } else if (recipe.creditText) {
                    sourceName = recipe.creditText;
                }
                document.getElementById('recipe-source-name').value = sourceName;
                
                if (recipe.recipeYield) {
                    const yieldString = Array.isArray(recipe.recipeYield) ? recipe.recipeYield[0] : recipe.recipeYield;
                    const yieldParts = yieldString.toString().match(/(\d+\.?\d*)\s*(.*)/);
                    if (yieldParts) {
                        document.getElementById('recipe-yield-quantity').value = yieldParts[1] || '';
                        document.getElementById('recipe-yield-unit').value = yieldParts[2].trim() || 'servings';
                    }
                }

                document.getElementById('recipe-prep-time').value = parseISODurationToMinutes(recipe.prepTime) || '';
                document.getElementById('recipe-cook-time').value = parseISODurationToMinutes(recipe.cookTime) || '';
                document.getElementById('recipe-total-time').value = parseISODurationToMinutes(recipe.totalTime) || '';

                if (recipe.datePublished) {
                    document.getElementById('recipe-discovered-date').value = new Date(recipe.datePublished).toISOString().split('T')[0];
                }
                
                document.getElementById('recipe-ingredients').value = formatSections(normalizeJsonLdStructure(recipe.recipeIngredient, 'Ingredients'));
                
                // FIX: Define and process instructions before rendering
                const instructions = normalizeJsonLdStructure(recipe.recipeInstructions, 'Instructions');
                renderInstructionBuilder(instructions);
                
                let notes = '';
                if (Array.isArray(recipe.comment)) {
                    notes = recipe.comment.map(c => c.text).join('\n\n');
                } else if (typeof recipe.comment === 'object' && recipe.comment !== null && recipe.comment.text) {
                    notes = recipe.comment.text;
                }
                document.getElementById('recipe-notes').value = notes;

                let labels = [];
                if (recipe.keywords) {
                    const keywords = Array.isArray(recipe.keywords) ? recipe.keywords : recipe.keywords.split(',').map(k => k.trim());
                    labels.push(...keywords);
                }
                if (recipe.recipeCategory) {
                    const categories = Array.isArray(recipe.recipeCategory) ? recipe.recipeCategory : [recipe.recipeCategory];
                    labels.push(...categories);
                }
                if (!labels.some(l => l.toLowerCase() === 'imported')) {
                    labels.push('imported');
                }
                document.getElementById('recipe-labels').value = [...new Set(labels)].join(', ');
                
                renderAddRatingStars(0);
                formSummary.textContent = `Importing: ${recipe.name}`;
                addRecipeBtn.textContent = "Add Recipe";
            }

            function prepareRecipeDataForImport(recipe, importUrl) {
                let sourceName = '';
                if (recipe.creditText) {
                    sourceName = recipe.creditText;
                } else if (typeof recipe.author === 'object' && recipe.author !== null) {
                    sourceName = recipe.author.name || '';
                } else if (recipe.author) {
                    sourceName = recipe.author;
                }

                let yieldQuantity = null;
                let yieldUnit = 'servings';
                if (recipe.recipeYield) {
                    const yieldString = Array.isArray(recipe.recipeYield) ? recipe.recipeYield[0] : recipe.recipeYield;
                    const yieldParts = yieldString.toString().match(/(\d+\.?\d*)\s*(.*)/);
                    if (yieldParts) {
                        yieldQuantity = Number(yieldParts[1]) || null;
                        yieldUnit = yieldParts[2].trim() || 'servings';
                    }
                }

                let labels = [];
                if (recipe.keywords) {
                    const keywords = Array.isArray(recipe.keywords) ? recipe.keywords : recipe.keywords.split(/[,/]/).map(k => k.trim()).filter(Boolean);
                    labels.push(...keywords);
                }
                if (recipe.recipeCategory) {
                    const categories = Array.isArray(recipe.recipeCategory) ? recipe.recipeCategory : [recipe.recipeCategory];
                    labels.push(...categories);
                }
                if(!labels.some(l => l.toLowerCase() === 'imported')) {
                    labels.push('imported');
                }

                const ingredients = normalizeJsonLdStructure(recipe.recipeIngredient, 'Ingredients');
                const instructions = normalizeJsonLdStructure(recipe.recipeInstructions, 'Instructions');
                
                let notes = '';
                if (Array.isArray(recipe.comment)) {
                    notes = recipe.comment.map(c => c.text).join('\n\n');
                } else if (typeof recipe.comment === 'object' && recipe.comment !== null && recipe.comment.text) {
                    notes = recipe.comment.text;
                }

                return {
                    name: recipe.name || 'Untitled Recipe',
                    description: recipe.description || '',
                    cuisine: recipe.recipeCuisine || '',
                    sourceUrl: recipe.isBasedOn || recipe.url || importUrl,
                    sourceName: sourceName,
                    yield: { quantity: yieldQuantity, unit: yieldUnit },
                    prepTime: parseISODurationToMinutes(recipe.prepTime) || 0,
                    cookTime: parseISODurationToMinutes(recipe.cookTime) || 0,
                    totalTime: parseISODurationToMinutes(recipe.totalTime) || 0,
                    discoveredDate: recipe.datePublished ? new Date(recipe.datePublished).toISOString().split('T')[0] : '',
                    ingredients: ingredients,
                    instructions: instructions,
                    notes: notes,
                    labels: [...new Set(labels)],
                    imageUrl: getImageUrl(recipe.image) || '',
                    rating: recipe.rating || 0,
                    ingredientNotes: {},
                    instructionNotes: {},
                    approvals: [],
                    createdAt: recipe.datePublished ? new Date(recipe.datePublished) : serverTimestamp(),
                    updatedAt: serverTimestamp(),
                    createdBy: userId,
                    updatedBy: userId,
                    importedFromUrl: importUrl,
                    importedAt: serverTimestamp()
                };
            }

            async function handleFetchFromUrl(url, type) {
                if (!url) {
                    showNotification('Please enter a URL.', 'error');
                    return;
                }
                const btn = type === 'txt' ? fetchTxtUrlBtn : fetchUrlBtn;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Fetching...';
                importReviewSection.classList.add('hidden');

                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    if (type === 'txt') {
                        const textContent = await response.text();
                        fetchedRecipesCache = parseRecipeSageTxt(textContent);
                        showNotification('Successfully parsed TXT data.', 'success');
                    } else { // jsonld
                        const data = await response.json();
                        fetchedRecipesCache = data.recipes || (Array.isArray(data) ? data : [data]);
                        showNotification('Successfully parsed JSON-LD data.', 'success');
                    }
                    
                    if (!fetchedRecipesCache || fetchedRecipesCache.length === 0) {
                        showNotification('No recipes found at that URL or in the file.', 'error');
                        return;
                    }
                    
                    importSummaryText.textContent = `Found ${fetchedRecipesCache.length} recipe(s) in this file.`;
                    batchImportBtn.textContent = `Import All (${fetchedRecipesCache.length} recipes)`;
                    importReviewSection.classList.remove('hidden');

                } catch (error) {
                    console.error('Import failed:', error);
                    showNotification('Failed to fetch recipe data. Check the URL and file type.', 'error');
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = type === 'txt' ? 'Fetch TXT' : 'Fetch JSON-LD';
                }
            }


            async function handleBatchImport() {
                if(fetchedRecipesCache.length === 0) {
                    showNotification('No recipes to import.', 'error');
                    return;
                }

                showNotification(`Importing ${fetchedRecipesCache.length} recipes...`, 'info', 0);
                const url = document.getElementById('import-url-input').value.trim() || document.getElementById('import-txt-url-input').value.trim();
                const batch = writeBatch(db);
                const recipesCol = collection(db, `users/${userId}/recipes`);

                fetchedRecipesCache.forEach(recipeJson => {
                    const recipeData = prepareRecipeDataForImport(recipeJson, url);
                    const newRecipeRef = doc(recipesCol);
                    batch.set(newRecipeRef, recipeData);
                });

                try {
                    await batch.commit();
                    showNotification(`Successfully imported ${fetchedRecipesCache.length} recipes!`, 'success');
                    resetForm();
                    await loadRecipes();
                    switchTab('recipes');
                } catch(error) {
                    console.error("Batch import error:", error);
                    showNotification("An error occurred during the batch import.", "error");
                }
            }
            
            function showNextImportModal() {
                const promptText = document.getElementById('next-import-prompt-text');
                promptText.textContent = `You have ${fetchedRecipesCache.length} more recipes to import. Load the next one into the editor?`;
                nextImportModalEl.classList.remove('hidden');
                nextImportModalEl.classList.add('flex');
            }

             async function renderTimeline() {
                timelineContainer.innerHTML = '<p class="text-gray-500">Loading timeline...</p>';
                if (!userId) return;

                try {
                    let allHistory = [];
                    for (const recipe of recipesCache) {
                        const historyCol = collection(db, 'users', userId, 'recipes', recipe.id, 'history');
                        const historySnapshot = await getDocs(historyCol);
                        historySnapshot.forEach(doc => {
                            allHistory.push({ recipeName: recipe.name, recipeId: recipe.id, ...doc.data() });
                        });
                    }

                    allHistory.sort((a, b) => new Date(b.cookedAt) - new Date(a.cookedAt));

                    if (allHistory.length === 0) {
                        timelineContainer.innerHTML = '<p class="text-gray-500">No cooking history to display.</p>';
                        return;
                    }

                    const groupedByYear = allHistory.reduce((acc, log) => {
                        const year = new Date(log.cookedAt).getFullYear();
                        if (!acc[year]) acc[year] = [];
                        acc[year].push(log);
                        return acc;
                    }, {});

                    timelineContainer.innerHTML = '';
                    const sortedYears = Object.keys(groupedByYear).sort((a, b) => b - a);

                    sortedYears.forEach(year => {
                        const yearSection = document.createElement('div');
                        yearSection.innerHTML = `<h3 class="text-2xl font-bold mb-4">${year}</h3>`;
                        const yearGrid = document.createElement('div');
                        yearGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';
                        
                        groupedByYear[year].forEach(log => {
                            const cookedDate = new Date(log.cookedAt).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                            const ratingHtml = Array.from({length: 5}, (_, i) => `<i class="fas fa-star text-xs ${i < log.rating ? 'text-yellow-400' : 'text-gray-300'}"></i>`).join('');
                            
                            const logCard = document.createElement('div');
                            logCard.className = 'bg-gray-100 dark:bg-gray-700 p-4 rounded-lg';
                            logCard.innerHTML = `
                                <div class="flex justify-between items-start">
                                    <div>
                                        <p class="font-bold cursor-pointer hover:underline" data-recipe-id="${log.recipeId}">${log.recipeName}</p>
                                        <p class="text-sm text-gray-500 dark:text-gray-400">${cookedDate}</p>
                                    </div>
                                    <div class="flex">${ratingHtml}</div>
                                </div>
                                ${log.imageUrl ? `<img src="${log.imageUrl}" class="w-full h-32 object-cover rounded-md my-2">` : ''}
                                <p class="text-sm mt-2 italic">"${log.notes || 'No notes.'}"</p>
                            `;
                             logCard.querySelector('.font-bold').addEventListener('click', (e) => {
                                showRecipeDetailsModal(e.target.dataset.recipeId);
                            });
                            yearGrid.appendChild(logCard);
                        });
                        yearSection.appendChild(yearGrid);
                        timelineContainer.appendChild(yearSection);
                    });

                } catch (error) {
                    console.error("Error rendering timeline:", error);
                    timelineContainer.innerHTML = '<p class="text-red-500">Could not load timeline.</p>';
                }
            }

            function populateLinkedRecipesSelect(selectedIds = []) {
                const select = document.getElementById('linked-recipes-select');
                select.innerHTML = '';
                recipesCache
                    .filter(r => r.id !== editingRecipeId)
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .forEach(recipe => {
                        const option = document.createElement('option');
                        option.value = recipe.id;
                        option.textContent = recipe.name;
                        if (selectedIds.includes(recipe.id)) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
            }
            
            // --- Event Listeners ---
            const selectByLabelBtn = document.getElementById('select-by-label-btn');

            recipesTabBtn.addEventListener('click', () => switchTab('recipes'));
            addRecipeTabBtn.addEventListener('click', () => {
                resetForm();
                switchTab('add-recipe');
            });
            timelineTabBtn.addEventListener('click', () => switchTab('timeline'));

            fetchUrlBtn.addEventListener('click', () => handleFetchFromUrl(document.getElementById('import-url-input').value.trim(), 'jsonld'));
            fetchTxtUrlBtn.addEventListener('click', () => handleFetchFromUrl(document.getElementById('import-txt-url-input').value.trim(), 'txt'));
            importFileInput.addEventListener('change', handleFileImport);
            batchImportBtn.addEventListener('click', handleBatchImport);
            loadFirstRecipeBtn.addEventListener('click', () => {
                if(fetchedRecipesCache.length > 0) {
                    populateFormWithImportedData(fetchedRecipesCache[0]);
                }
            });

            document.getElementById('next-import-confirm-btn').addEventListener('click', () => {
                nextImportModalEl.classList.add('hidden');
                nextImportModalEl.classList.remove('flex');
                if (fetchedRecipesCache.length > 0) {
                    populateFormWithImportedData(fetchedRecipesCache[0]);
                }
            });

            document.getElementById('next-import-cancel-btn').addEventListener('click', () => {
                nextImportModalEl.classList.add('hidden');
                nextImportModalEl.classList.remove('flex');
                resetForm();
            });
            
            themeToggle.addEventListener('click', () => {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            optionsBtn.addEventListener('click', (e) => { e.stopPropagation(); optionsPanel.classList.toggle('hidden'); });
            manageAppliancesBtn.addEventListener('click', () => {
                optionsPanel.classList.add('hidden');
                showAppliancesModal();
            });
            document.addEventListener('click', (e) => { if (optionsPanel && !optionsPanel.contains(e.target) && !optionsBtn.contains(e.target)) { optionsPanel.classList.add('hidden'); }});
            layoutSelect.addEventListener('change', () => { currentLayout = layoutSelect.value; savePreferences(); filterRecipes(); });
            sortBySelect.addEventListener('change', () => { currentSort = sortBySelect.value; savePreferences(); filterRecipes(); });
            document.querySelectorAll('[id$="-toggle"]').forEach(toggle => {
                toggle.addEventListener('change', (e) => {
                    const key = e.target.id.replace(/-toggle$/, '').replace(/-(\w)/g, (match, p1) => p1.toUpperCase());
                    displayOptions[key] = e.target.checked;
                    savePreferences();
                    filterRecipes();
                });
            });
            multiSelectBtn.addEventListener('click', () => { isMultiSelectMode = true; isShoppingListMode = false; generateShoppingListBtn.classList.add('hidden'); bulkDeleteBtn.classList.remove('hidden'); updateMultiSelectUI(); filterRecipes(); });
            shoppingListModeBtn.addEventListener('click', () => { isMultiSelectMode = true; isShoppingListMode = true; generateShoppingListBtn.classList.remove('hidden'); bulkDeleteBtn.classList.add('hidden'); updateMultiSelectUI(); filterRecipes(); });
            
            selectByLabelBtn.addEventListener('click', () => {
                const selectedLabel = filterLabel.value;
                if (!selectedLabel) return;

                const recipesToSelect = recipesCache.filter(recipe => recipe.labels && recipe.labels.includes(selectedLabel));
                
                if (recipesToSelect.length === 0) {
                    showNotification('No recipes found with that label.', 'info');
                    return;
                }

                isMultiSelectMode = true;
                isShoppingListMode = false;
                generateShoppingListBtn.classList.add('hidden');
                bulkDeleteBtn.classList.remove('hidden');
                
                recipesToSelect.forEach(recipe => selectedRecipeIds.add(recipe.id));
                
                updateMultiSelectUI();
                filterRecipes();
                optionsPanel.classList.add('hidden');
                showNotification(`${recipesToSelect.length} recipes with label "${selectedLabel}" selected.`, 'success');
            });

            cancelSelectionBtn.addEventListener('click', () => { isMultiSelectMode = false; isShoppingListMode = false; selectedRecipeIds.clear(); updateMultiSelectUI(); filterRecipes(); });
            bulkDeleteBtn.addEventListener('click', async () => {
                if (confirm(`Are you sure you want to delete ${selectedRecipeIds.size} recipes? This action cannot be undone.`)) {
                    const deletePromises = Array.from(selectedRecipeIds).map(id => deleteDoc(doc(db, 'users', userId, 'recipes', id)));
                    try {
                        await Promise.all(deletePromises);
                        showNotification(`${selectedRecipeIds.size} recipes deleted successfully.`);
                        isMultiSelectMode = false; selectedRecipeIds.clear(); updateMultiSelectUI(); loadRecipes();
                    } catch (error) { showNotification("Failed to delete recipes.", "error"); console.error("Bulk delete error:", error); }
                }
            });
            generateShoppingListBtn.addEventListener('click', () => {
                let combinedIngredients = {};
                selectedRecipeIds.forEach(id => {
                    const recipe = recipesCache.find(r => r.id === id);
                    if (recipe) {
                        const ingredientsData = processData(recipe.ingredients, 'Ingredients');
                        ingredientsData.forEach(section => {
                            (section.items || []).forEach(item => {
                                const mainItem = item.text.split('##')[0].trim();
                                if (mainItem) {
                                    if (!combinedIngredients[mainItem]) combinedIngredients[mainItem] = 0;
                                    combinedIngredients[mainItem]++;
                                }
                            });
                        });
                    }
                });
                let shoppingListText = 'Shopping List:\n\n' + Object.keys(combinedIngredients).sort().map(key => `- ${key}`).join('\n');
                navigator.clipboard.writeText(shoppingListText);
                showNotification("Shopping list copied to clipboard!");
            });
            addRecipeBtn.addEventListener('click', handleAddOrUpdateRecipe);
            searchBar.addEventListener('input', filterRecipes);
            
            filterLabel.addEventListener('change', () => {
                filterRecipes();
                selectByLabelBtn.disabled = !filterLabel.value;
            });

            filterCuisine.addEventListener('change', filterRecipes);
            filterRating.addEventListener('change', filterRecipes);
            clearFiltersBtn.addEventListener('click', () => {
                searchBar.value = ''; filterCuisine.value = ''; filterLabel.value = ''; filterRating.value = '0';
                selectByLabelBtn.disabled = true;
                filterRecipes();
            });
            
            // --- Initial Load ---
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme)
            } else {
                 applyTheme('dark');
            }


            loadPreferences();
            onAuthStateChanged(auth, user => {
                if (user) { 
                    userId = user.uid; 
                    loadRecipes(); 
                    loadAppliances();
                } 
                else { 
                    userId = null; 
                    recipesCache = [];
                    appliancesCache = [];
                    recipeList.innerHTML = '<p class="text-center col-span-full">Please log in to see your recipes.</p>'; 
                }
            });
        });
    </script>
</body>
</html>